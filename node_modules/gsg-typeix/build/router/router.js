"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var Router_1;
const logger_1 = require("../logger/logger");
const error_1 = require("../error");
const core_1 = require("../core");
const injector_1 = require("../injector/injector");
const route_rule_1 = require("./route-rule");
const injectable_1 = require("../decorators/injectable");
const inject_1 = require("../decorators/inject");
const status_code_1 = require("../server/status-code");
/**
 * @since 1.0.0
 * @enum
 * @name Methods
 *
 * @description
 * ControllerResolver methods
 */
var Methods;
(function (Methods) {
    Methods[Methods["GET"] = 0] = "GET";
    Methods[Methods["HEAD"] = 1] = "HEAD";
    Methods[Methods["DELETE"] = 2] = "DELETE";
    Methods[Methods["TRACE"] = 3] = "TRACE";
    Methods[Methods["OPTIONS"] = 4] = "OPTIONS";
    Methods[Methods["CONNECT"] = 5] = "CONNECT";
    Methods[Methods["POST"] = 6] = "POST";
    Methods[Methods["PUT"] = 7] = "PUT";
    Methods[Methods["PATCH"] = 8] = "PATCH";
})(Methods = exports.Methods || (exports.Methods = {}));
/**
 * @since 1.0.0
 * @function
 * @name getMethodName
 * @param {string} method
 *
 * @description
 * Get method name from Methods enum
 */
function getMethodName(method) {
    if (core_1.isEqual(Methods.GET, method)) {
        return "GET";
    }
    else if (core_1.isEqual(Methods.HEAD, method)) {
        return "HEAD";
    }
    else if (core_1.isEqual(Methods.DELETE, method)) {
        return "DELETE";
    }
    else if (core_1.isEqual(Methods.TRACE, method)) {
        return "TRACE";
    }
    else if (core_1.isEqual(Methods.OPTIONS, method)) {
        return "OPTIONS";
    }
    else if (core_1.isEqual(Methods.CONNECT, method)) {
        return "CONNECT";
    }
    else if (core_1.isEqual(Methods.POST, method)) {
        return "POST";
    }
    else if (core_1.isEqual(Methods.PUT, method)) {
        return "PUT";
    }
    else if (core_1.isEqual(Methods.PATCH, method)) {
        return "PATCH";
    }
}
exports.getMethodName = getMethodName;
/**
 * @since 1.0.0
 * @function
 * @name getMethod
 * @param {string} method
 *
 * @description
 * Get method enum from method string
 * @throws TypeError
 */
function getMethod(method) {
    if (method === "GET") {
        return Methods.GET;
    }
    else if (method === "HEAD") {
        return Methods.HEAD;
    }
    else if (method === "DELETE") {
        return Methods.DELETE;
    }
    else if (method === "TRACE") {
        return Methods.TRACE;
    }
    else if (method === "OPTIONS") {
        return Methods.OPTIONS;
    }
    else if (method === "CONNECT") {
        return Methods.CONNECT;
    }
    else if (method === "POST") {
        return Methods.POST;
    }
    else if (method === "PUT") {
        return Methods.PUT;
    }
    else if (method === "PATCH") {
        return Methods.PATCH;
    }
    throw new TypeError(`Method ${method} is not known method by standard!`);
}
exports.getMethod = getMethod;
/**
 * @since 1.0.0
 * @class
 * @name Router
 * @constructor
 * @description
 * Router is a component for handling routing in system.
 * All routes should be added during bootstrap process
 * @example
 * import { Bootstrap, Router } from "../core";
 * import { Assets } from "./components/assets";
 *
 * \@Bootstrap({
 *    port: 9000
 * })
 * export class Application {
 *   constructor(assets: Assets, router: Router) {
 *       router.add()
 *   }
 * }
 */
let Router = Router_1 = class Router {
    /**
     * @since 1.0.0
     * @class
     * @name Router
     * @constructor
     * @description
     * Router is a component for handling routing in system.
     * All routes should be added during bootstrap process
     * @example
     * import { Bootstrap, Router } from "../core";
     * import { Assets } from "./components/assets";
     *
     * \@Bootstrap({
     *    port: 9000
     * })
     * export class Application {
     *   constructor(assets: Assets, router: Router) {
     *       router.add()
     *   }
     * }
     */
    constructor() {
        /**
         * @param {Array<Route>} routes
         */
        this.routes = [];
        /**
         * ErrorMessage route definition
         * @param {String} errorRoute
         */
        this.errorRoutes = [];
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#prefixSlash
     * @param {string} value
     * @static
     * @private
     *
     * @description
     * Prefixes url with starting slash
     */
    static prefixSlash(value) {
        return value.charAt(0) === "/" ? value : "/" + value;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#getError
     *
     * @description
     * Returns error route string
     */
    getError(module) {
        let routes = this.errorRoutes.slice();
        let item;
        while (routes.length > 0) {
            item = routes.pop();
            if (item.startsWith(module + "/")) {
                return item;
            }
        }
        return item;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#hasErrorRoute
     *
     * @description
     * Check if error route is provided
     */
    hasError() {
        return core_1.isTruthy(this.errorRoutes.length > 0);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#setError
     * @param {string} route
     *
     * @description
     * Add error route
     */
    setError(route) {
        if (this.errorRoutes.indexOf(route) === -1 && core_1.isString(route)) {
            let list = route.split("/");
            if (list.length < 2) {
                throw new Error(`Invalid route structure: "${route}"! Valid are controller/action or module/controller/action!`);
            }
            this.errorRoutes.push(route);
        }
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#addRules
     * @param {Array<RouteRuleConfig>} rules
     *
     * @description
     * Add route to routes list.
     * All routes must be inherited from Route interface.
     */
    addRules(rules) {
        this.logger.info("Router.addRules", rules);
        rules.forEach(config => this.routes.push(this.createRule(route_rule_1.RouteRule, config)));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#addRule
     * @param {Function} Class
     * @param {RouteRuleConfig} config
     *
     * @description
     * Create rule and add rule to list
     */
    addRule(Class, config) {
        this.logger.info("Router.addRule", Class);
        this.routes.push(this.createRule(Class, config));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#createRule
     * @param {Function} Class
     * @param {RouteRuleConfig} config
     *
     * @description
     * Initialize rule
     */
    createRule(Class, config) {
        let injector = injector_1.Injector.createAndResolveChild(this.injector, Class, core_1.isPresent(config) ? [{ provide: "config", useValue: config }] : []);
        return injector.get(Class);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#parseRequest
     * @param {String} pathName
     * @param {String} method
     * @param {Headers} headers
     *
     * @description
     * Parse request based on pathName and method
     */
    parseRequest(pathName, method, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let route of this.routes) {
                let result = yield route.parseRequest(pathName, method, headers);
                if (core_1.isTruthy(result) && !core_1.isEqual(true, result)) {
                    this.logger.debug("Router.parseRequest", result);
                    return Promise.resolve(result);
                }
            }
            throw new error_1.HttpError(status_code_1.Status.Not_Found, `Router.parseRequest: ${pathName} no route found, method: ${method}`, {
                pathName,
                method
            });
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#createUrl
     * @param {String} routeName
     * @param {Object} params
     *
     * @description
     * Create url based on route and params
     */
    createUrl(routeName, params) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let route of this.routes) {
                let result = yield route.createUrl(routeName, params);
                if (core_1.isTruthy(result) && !core_1.isEqual(true, result)) {
                    this.logger.info("Router.createUrl", result);
                    return Promise.resolve(Router_1.prefixSlash(result));
                }
            }
            if (Object.keys(params).length > 0) {
                routeName += "?";
                Object.keys(params).forEach((k) => {
                    routeName += k + "=" + encodeURIComponent(params[k]);
                });
            }
            this.logger.info("Router.createUrl", Router_1.prefixSlash(routeName));
            return Promise.resolve(Router_1.prefixSlash(routeName));
        });
    }
};
__decorate([
    inject_1.Inject(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], Router.prototype, "logger", void 0);
__decorate([
    inject_1.Inject(injector_1.Injector),
    __metadata("design:type", injector_1.Injector)
], Router.prototype, "injector", void 0);
Router = Router_1 = __decorate([
    injectable_1.Injectable()
], Router);
exports.Router = Router;
//# sourceMappingURL=router.js.map