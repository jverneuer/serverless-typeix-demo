"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../core");
const router_1 = require("./router");
const IS_ANY_PATTERN = /<([^>]+)>/;
const PATTERN_MATCH = /<(\w+):([^>]+)>/g;
const HAS_GROUP_START = /^\(/;
const HAS_GROUP_END = /\)$/;
const PATH_START = /^\//;
const PATH = /\//;
const PATH_SPLIT = /\/([^><]+|<\w+:[^>]+>|\w+)\//;
/**
 * @since 1.0.0
 * @function
 * @name PatternChunk
 * @constructor
 *
 * @param {string} replace
 * @param {string} param
 * @param {number} index
 * @param {string} source
 *
 * @description
 * Pattern chunk used by pattern
 */
class PatternChunk {
    constructor(index, replace, source, param) {
        this.index = index;
        this.replace = replace;
        this.source = source;
        this.param = param;
        this.regex = new RegExp("^" + source + "$");
    }
    /**
     * @since 1.0.0
     * @function
     * @name PatternChunk#getRegex
     *
     * @description
     * Get regex from source
     */
    getRegex() {
        return this.regex;
    }
    /**
     * @since 1.0.0
     * @function
     * @name PatternChunk#getIndex
     *
     * @description
     * Get index
     */
    getIndex() {
        return this.index;
    }
    /**
     * @since 1.0.0
     * @function
     * @name PatternChunk#getReplaceMatcher
     *
     * @description
     * Get replace matcher
     */
    getReplaceMatcher() {
        return this.replace;
    }
    /**
     * @since 1.0.0
     * @function
     * @name PatternChunk#getSource
     *
     * @description
     * Get source
     */
    getSource() {
        return this.source;
    }
    /**
     * @since 1.0.0
     * @function
     * @name PatternChunk#getParam
     *
     * @description
     * Get parameter
     */
    getParam() {
        return this.param;
    }
}
exports.PatternChunk = PatternChunk;
/**
 * @since 1.0.0
 * @function
 * @name Pattern
 * @constructor
 *
 * @param {path} path
 * @param {regex} replace
 * @param {chunks} param
 *
 * @description
 * Route match pattern
 */
class Pattern {
    constructor(path, source, regex, chunks) {
        this.path = path;
        this.source = source;
        this.regex = regex;
        this.chunks = chunks;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Pattern#normalizePath
     *
     * @description
     * Creates path from chunks throws error if no param is correct data type or if it dosen't exist
     *
     * @throws Error
     */
    normalizePath(params) {
        let path = this.path;
        this.chunks.forEach(chunk => {
            if (!params.hasOwnProperty(chunk.getParam())) {
                throw new Error(`Param ${chunk.getParam()} is missing in parameters provided!`);
            }
            let param = params[chunk.getParam()];
            if (!chunk.getRegex().test(param)) {
                throw new TypeError(`Param ${chunk.getParam()} is not valid type, provided value: "${param}" 
        is tested with regex: ${chunk.getSource()}`);
            }
            path = path.replace(chunk.getReplaceMatcher(), param);
        });
        return path;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Pattern#getSource
     *
     * @description
     * Get source pattern
     */
    getSource() {
        return this.source;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Pattern#getChunks
     *
     * @description
     * Get array chunks
     */
    getChunks() {
        return this.chunks;
    }
}
exports.Pattern = Pattern;
/**
 * @since 1.0.0
 * @function
 * @name RouteParser
 * @constructor
 *
 * @param {IUrlTreePath} tree
 *
 * @description
 * RouteParser is responsible for parsing routes
 */
class RouteParser {
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#toPattern
     * @param {String} path
     * @static
     *
     * @description
     * Creates pattern based on path provided
     * @example
     * RouteParser.toPattern("<param_a:(\\w+)>-<param_b:([a-zA-Z]+)>-now-<param_c:\\d+>-not");
     */
    static toPattern(path) {
        let patterns = [];
        let pattern = null;
        /**
         * Parse patterns
         */
        if (PATTERN_MATCH.test(path)) {
            pattern = path.replace(PATTERN_MATCH, (replace, key, source, index) => {
                if (!HAS_GROUP_START.test(source) || !HAS_GROUP_END.test(source)) {
                    source = "(" + source + ")";
                }
                patterns.push(new PatternChunk(index, replace, source, key));
                return source;
            });
        }
        else if (IS_ANY_PATTERN.test(path)) {
            pattern = path.replace(IS_ANY_PATTERN, (replace, key, index) => {
                let source = "([\\s\\S]+)";
                patterns.push(new PatternChunk(index, replace, source, key));
                return source;
            });
        }
        else if (path === "*") {
            pattern = "([\\s\\S]+)";
        }
        else {
            pattern = path;
        }
        return new Pattern(path, pattern, new RegExp("^" + pattern + "$"), patterns);
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#parse
     * @param {String} url
     * @static
     *
     * @description
     * Creates url tree which is used by RouteParser for easier pattern creation
     *
     * @example
     * RouteParser.parse("/can<any>one/<name:\\w+>/should<now:\\W+>do-it/<see:(\\w+)>-<nice:([a-zA-Z]+)>-now-<only:\\d+>-not/user/<id:\\d+>");
     *
     */
    static parse(url) {
        let chunks = url.split(PATH_SPLIT).filter(core_1.isTruthy);
        if (core_1.isFalsy(url) || ["/", "*"].indexOf(url.charAt(0)) === -1) {
            throw new Error("Url must start with \/ or it has to be * which match all patterns");
        }
        else if (chunks.length > 1) {
            let tree = chunks.reduceRight((cTree, currentValue) => {
                let obj = {
                    child: null,
                    path: currentValue
                };
                if (core_1.isPresent(cTree)) {
                    obj.child = core_1.isObject(cTree) ? cTree : { child: null, path: cTree };
                }
                return obj;
            });
            return new RouteParser(tree);
        }
        return new RouteParser({
            child: null,
            path: url
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser
     * @param {IUrlTreePath} tree
     * @param {RouteParser} parent
     * @constructor
     *
     * @description
     * Creates pattern based on path provided
     * @example
     * let tree = RouteParser.toUrlTree("/<param_a:(\\w+)>-<param_b:([a-zA-Z]+)>-now-<param_c:\\d+>-not/bcd");
     * let parsedRoute = new RouteParser(tree);
     */
    constructor(tree, parent) {
        this.path = tree.path;
        if (core_1.isPresent(parent)) {
            this.parent = parent;
        }
        if (core_1.isPresent(tree.child)) {
            this.child = new RouteParser(tree.child, this);
        }
        this.pattern = RouteParser.toPattern(this.path);
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#isValid
     * @param {String} url
     * @description
     * Check if url is valid
     */
    isValid(url) {
        let pattern = this.getPattern();
        let regex = new RegExp("^" + pattern + "$");
        return regex.test(url);
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#createUrl
     * @param {Object} params
     * @description
     * Create url if params are correct type if params are not valid it throws error
     * @throws Error
     */
    createUrl(params) {
        let head = this.getHead();
        let url = "";
        while (core_1.isPresent(head)) {
            let path = head.pattern.normalizePath(params);
            if (core_1.isTruthy(path)) {
                url += router_1.Router.prefixSlash(path);
            }
            head = head.child;
        }
        return url;
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#getParams
     * @param {String} url
     * @description
     * Extract params from url
     * @throws Error
     */
    getParams(url) {
        let data = {};
        let pattern = this.getPattern();
        if (!this.isValid(url)) {
            throw new Error(`Url ${url} is not matching current pattern!`);
        }
        let chunks = url.match(pattern).slice(1);
        this.toChunksArray().forEach((item, index) => data[item.getParam()] = chunks[index]);
        return data;
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#toArray
     * @description
     * Convert parser tree to array
     */
    toChunksArray() {
        let data = [];
        let chunk = this.getHead();
        while (core_1.isTruthy(chunk)) {
            data = data.concat(chunk.pattern.getChunks());
            chunk = chunk.child;
        }
        return data;
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#getPattern
     * @description
     * Get route pattern
     */
    getPattern() {
        let pattern = "";
        let chunk = this.getHead();
        while (core_1.isTruthy(chunk)) {
            let source = chunk.pattern.getSource();
            if (PATH_START.test(source)) {
                pattern = source;
            }
            else {
                pattern += PATH.source + source;
            }
            chunk = chunk.child;
        }
        return pattern;
    }
    /**
     * @since 1.0.0
     * @function
     * @name RouteParser#getHead
     * @return {RouteParser}
     * @private
     *
     * @description
     * Return head RouteParser
     *
     */
    getHead() {
        if (core_1.isPresent(this.parent)) {
            return this.parent.getHead();
        }
        return this;
    }
}
exports.RouteParser = RouteParser;
//# sourceMappingURL=route-parser.js.map