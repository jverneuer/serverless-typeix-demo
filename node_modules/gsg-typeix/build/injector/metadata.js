"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const core_1 = require("../core");
exports.INJECT_KEYS = "inject:paramtypes";
exports.FUNCTION_KEYS = "function:decorators";
exports.FUNCTION_PARAMS = "function:paramtypes";
exports.DESIGN_PARAMTYPES_KEYS = "design:paramtypes";
exports.DESIGN_KEYS = "design:type";
exports.DESIGN_RETURN = "design:returntype";
exports.COMPONENT_CONFIG_KEYS = "component:paramtypes";
/**
 * @since 1.0.0
 * @constructor
 * @function
 * @name Metadata
 *
 * @description
 * Metadata is responsible for getting or setting metadata definitions for some Class
 * It's crucial for injector
 */
class Metadata {
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getName
     * @param {Object} Class
     * @param {string} prefix
     *
     * @description
     * Get class name
     */
    static getName(Class, prefix) {
        if (Metadata.isProvider(Class)) {
            return Metadata.getName(Class.provide);
        }
        else if (core_1.isString(Class)) {
            return "String: " + Class;
        }
        let message = "";
        if (prefix) {
            message += prefix;
        }
        if (core_1.isPresent(Class)) {
            if (core_1.isPresent(Class.name)) {
                message += Class.name;
            }
            else if (core_1.isPresent(Class.constructor) && core_1.isPresent(Class.constructor.name)) {
                message += Class.constructor.name;
            }
        }
        return message;
    }
    ;
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#inVerifiedProvider
     *
     * @param providers
     * @param provider
     * @returns {boolean}
     *
     * @description
     * Check if provider is in array of providers
     */
    static inVerifiedProviders(providers, provider) {
        return providers.some(item => core_1.isEqual(item.provide, provider.provide));
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getVerifiedProvider
     *
     * @param providers
     * @param provider
     * @returns {boolean}
     *
     * @description
     * Get verified provider in providers
     */
    static getVerifiedProvider(providers, provider) {
        return providers.find(item => core_1.isEqual(item.provide, provider.provide));
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#inProviders
     *
     * @param providers
     * @param provider
     * @returns {boolean}
     *
     * @description
     * Check if provider is in array of providers
     */
    static inProviders(providers, provider) {
        return Metadata.inVerifiedProviders(Metadata.verifyProviders(providers), Metadata.verifyProvider(provider));
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getProviderInProviders
     *
     * @param {Array<any>} providers
     * @param {any} provider
     * @returns IProvider
     *
     * @description
     * Return provider in providers
     */
    static getProviderInProviders(providers, provider) {
        return Metadata.getVerifiedProvider(Metadata.verifyProviders(providers), Metadata.verifyProvider(provider));
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#isProvider
     * @param token
     * @returns {boolean}
     *
     * @description
     * Check if token is provider
     */
    static isProvider(token) {
        return core_1.isPresent(token) &&
            core_1.isObject(token) &&
            core_1.isPresent(token.provide) &&
            (core_1.isString(token.provide) || core_1.isClass(token.provide)) &&
            (core_1.isPresent(token.useValue) || core_1.isClass(token.useClass) || core_1.isFunction(token.useFactory));
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#isDescriptor
     * @param {Object} value
     *
     * @description
     * Check if current object is descriptor object
     */
    static isDescriptor(value) {
        return core_1.isPresent(value) && ["writable", "configurable", "value", "enumerable"].every(key => value.hasOwnProperty(key));
    }
    ;
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#defineMetadata
     * @param {Function} token
     * @param {string} name
     * @param {Object} value
     * @return {any} value
     *
     * @description
     * Define metadata to some class
     */
    static defineMetadata(token, name, value) {
        if (core_1.isPresent(value)) {
            Reflect.defineMetadata(name, value, token);
            return true;
        }
        return false;
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#hasMetadata
     * @param {Function} token
     * @param {string} name
     *
     * @description
     * Check if some class has metadata by key
     */
    static hasMetadata(token, name) {
        try {
            return Reflect.hasMetadata(name, token);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getMetadata
     * @param {Function} token
     * @param {String} name
     * @param {any} defaultValue
     *
     * @description
     * Get class metadata if not present return defaultValue
     */
    static getMetadata(token, name, defaultValue = []) {
        return Metadata.hasMetadata(token, name) ? Reflect.getMetadata(name, token) : defaultValue;
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getComponentConfig
     * @param {Function} Class
     *
     * @description
     * Get component config
     */
    static getComponentConfig(Class) {
        return Metadata.getMetadata(Class, exports.COMPONENT_CONFIG_KEYS, {});
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#setComponentConfig
     * @param {Function} Class
     * @param {any} config
     *
     * @description
     * Sets component config
     */
    static setComponentConfig(Class, config) {
        Metadata.defineMetadata(Class, exports.COMPONENT_CONFIG_KEYS, config);
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getConstructorProviders
     * @param {Function} Class
     *
     * @description
     * Return constructor providers in order to be delivered new instance to current injectable class
     */
    static getConstructorProviders(Class) {
        if (core_1.isFunction(Class)) {
            let config = Metadata.getMetadata(Class, exports.COMPONENT_CONFIG_KEYS);
            if (core_1.isArray(config.providers)) {
                return config.providers.map(ProviderClass => Metadata.verifyProvider(ProviderClass));
            }
        }
        return [];
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getConstructorPrototypeKeys
     * @param {Function} Class
     *
     * @description
     * Get keys metadata in order to know what Injector should do with them
     */
    static getConstructorPrototypeKeys(Class) {
        return Metadata.getMetadata(Class.prototype, exports.INJECT_KEYS);
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#getConstructorInjectKeys
     * @param {Function} Class
     *
     * @description
     * Get all metadata on Class constructor so Injector can decide what to do with them
     */
    static getConstructorInjectKeys(Class) {
        let providers = Metadata.getMetadata(Class, exports.DESIGN_PARAMTYPES_KEYS);
        let injectors = Metadata.getMetadata(Class, exports.FUNCTION_PARAMS);
        if (core_1.isArray(injectors)) {
            injectors.forEach(item => providers.splice(item.paramIndex, 1, item.value));
        }
        return providers;
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#hasProvider
     * @param {Array} providers
     * @param {Function} Class
     *
     * @description
     * Check if some list of providers are containing provider Class
     */
    static hasProvider(providers, Class) {
        return providers.some(item => {
            if (core_1.isObject(item)) {
                return item.provide === Class;
            }
            return item === Class;
        });
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#mergeProviders
     * @param {Array<IProvider>} a
     * @param {Array<IProvider>} b
     *
     * @description
     * Merge two provider definitions, this is used by Injector internally to know what to deliver at what time.
     *
     * This might look confusing but it does copy only from b if does't exist in a and b is added to beginning of
     * sequence.
     *
     * It must be like that because module nesting issue.
     *
     */
    static mergeProviders(a, b) {
        return b.filter((bI) => core_1.isFalsy(a.find((aI) => aI.provide === bI.provide))).concat(a);
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#verifyProviders
     * @param {Array<any>} providers
     *
     * @description
     * Verify all providers in list
     */
    static verifyProviders(providers) {
        if (core_1.isArray(providers)) {
            return providers.map(ProviderClass => Metadata.verifyProvider(ProviderClass));
        }
        throw new TypeError(`Providers must be an Array type`);
    }
    /**
     * @since 1.0.0
     * @static
     * @function
     * @name Metadata#verifyProvider
     * @param {Any} value
     *
     * @description
     * Verify provider to be sure that metadata configuration is provided correctly so it can be used by Injector
     */
    static verifyProvider(value) {
        if (core_1.isFunction(value)) {
            return {
                provide: value,
                useClass: value
            };
        }
        else if (core_1.isObject(value)) {
            if (!core_1.isPresent(value.provide) || (!core_1.isString(value.provide) && !core_1.isFunction(value.provide))) {
                throw new TypeError(`IProvider.provider must be string or Class type, ${core_1.toString(value)}`);
            }
            if (core_1.isPresent(value.useClass)) {
                if (core_1.isPresent(value.useValue) || core_1.isPresent(value.useFactory)) {
                    throw new TypeError(`IProvider.useClass provider cannot have assigned useValue or useFactory`);
                }
                else if (!core_1.isFunction(value.useClass)) {
                    throw new TypeError(`IProvider.useClass must be Class type`);
                }
            }
            if (core_1.isPresent(value.useValue)) {
                if (core_1.isPresent(value.useClass) || core_1.isPresent(value.useFactory)) {
                    throw new TypeError(`IProvider.useValue provider cannot have assigned useClass or useFactory`);
                }
            }
            if (core_1.isPresent(value.useFactory)) {
                if (core_1.isPresent(value.useClass) || core_1.isPresent(value.useValue)) {
                    throw new TypeError(`IProvider.useFactory provider cannot have assigned useClass or useValue`);
                }
                else if (!core_1.isFunction(value.useFactory)) {
                    throw new TypeError(`IProvider.useFactory must be Function type`);
                }
            }
            if (!core_1.isPresent(value.useClass) && !core_1.isPresent(value.useValue) && !core_1.isPresent(value.useFactory)) {
                throw new TypeError(`IProvider members useClass or useValue or useFactory must be provided with IProvider`);
            }
            return value;
        }
        throw new TypeError(`Invalid provider config, provider must be an Class or IProvider type`);
    }
}
exports.Metadata = Metadata;
//# sourceMappingURL=metadata.js.map