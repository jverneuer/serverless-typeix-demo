"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = require("../injector/metadata");
const core_1 = require("../core");
/**
 * Action decorator
 * @decorator
 * @function
 * @private
 * @name mapAction
 *
 * @param {String} type
 *
 * @description
 * Multiple action type providers
 */
let mapAction = (type) => (value) => {
    return (Class, key, descriptor) => {
        let metadata = [];
        let className = metadata_1.Metadata.getName(Class);
        if (metadata_1.Metadata.hasMetadata(Class, metadata_1.FUNCTION_KEYS)) {
            metadata = metadata_1.Metadata.getMetadata(Class, metadata_1.FUNCTION_KEYS);
        }
        if (metadata.find(item => item.type === type && item.key === key && item.className === className)) {
            throw new TypeError(`Only one @${type} definition is allowed on ${key} ${metadata_1.Metadata.getName(Class, "on class ")}`);
        }
        else if (!metadata_1.Metadata.isDescriptor(descriptor) && !core_1.isEqual(Class, descriptor)) {
            throw new TypeError(`@${type} is allowed ony on function type ${metadata_1.Metadata.getName(Class, "on class ")}`);
        }
        let iAction = {
            type,
            key,
            value,
            proto: Class
        };
        metadata.push(iAction);
        metadata_1.Metadata.defineMetadata(Class, metadata_1.FUNCTION_KEYS, metadata);
        if (metadata_1.Metadata.isDescriptor(descriptor)) {
            descriptor.configurable = false;
            descriptor.writable = false;
        }
        return Class;
    };
};
/**
 * Action decorator
 * @decorator
 * @function
 * @name mapEachAction
 *
 * @param {String} type
 *
 * @description
 * Map each action type
 */
let mapEachAction = (type) => (Class, key, descriptor) => {
    let metadata = [];
    let className = metadata_1.Metadata.getName(Class);
    if (metadata_1.Metadata.hasMetadata(Class, metadata_1.FUNCTION_KEYS)) {
        metadata = metadata_1.Metadata.getMetadata(Class, metadata_1.FUNCTION_KEYS);
    }
    if (metadata.find(item => item.type === type && item.className === className)) {
        throw new TypeError(`Only one @${type} definition is allowed ${metadata_1.Metadata.getName(Class, "on class ")}`);
    }
    else if (!metadata_1.Metadata.isDescriptor(descriptor) && !core_1.isEqual(Class, descriptor)) {
        throw new TypeError(`@${type} is allowed ony on function type ${metadata_1.Metadata.getName(Class, "on class ")}`);
    }
    let iAction = {
        type,
        key,
        value: null,
        proto: Class
    };
    metadata.push(iAction);
    metadata_1.Metadata.defineMetadata(Class, metadata_1.FUNCTION_KEYS, metadata);
    if (metadata_1.Metadata.isDescriptor(descriptor)) {
        descriptor.configurable = false;
        descriptor.writable = false;
    }
    return Class;
};
/**
 * Action decorator
 * @decorator
 * @function
 * @name BeforeEach
 *
 * @description
 * Before each action
 */
exports.BeforeEach = mapEachAction("BeforeEach");
/**
 * Action decorator
 * @decorator
 * @function
 * @name AfterEach
 *
 * @description
 * After each action
 */
exports.AfterEach = mapEachAction("AfterEach");
/**
 * Action decorator
 * @decorator
 * @function
 * @name Action
 *
 * @param {String} value
 *
 * @description
 * Define name of action to class
 */
exports.Action = mapAction("Action");
/**
 * Before Action decorator
 * @decorator
 * @function
 * @name Before
 *
 * @param {String} value
 *
 * @description
 * Define name of before action to class
 */
exports.Before = mapAction("Before");
/**
 * After Action decorator
 * @decorator
 * @function
 * @name After
 *
 * @param {String} value
 *
 * @description
 * Define name of after action to class
 */
exports.After = mapAction("After");
/**
 * @since 2.0.0
 * @decorator
 * @function
 * @name Hook
 *
 * @param {String} value One of "verify"|"open"|"message"
 *
 * @description
 * Define a WebSocket method hook to be called for one of the actions "verify",
 * "open", or "message". All hooks support injection with {@link Inject} and {@link Param}.
 *
 * The "verify" hook is called before the socket is fully established. If you want to deny
 * opening the socket just throw an {@link HttpError}.
 *
 * When the socket is opened the "open" hook is called. You can inject the {@link Socket}
 * as parameter in this method in order to get access to the underlying Socket API.
 *
 * To receive and handle messages from the other side provide a "message" hook. You can inject
 * a parameter "message" there which is the data received over the socket.
 *
 * @example
 * import {WebSocket, Hook, BaseRequest} from "typeix";
 *
 * \@WebSocket({...})
 * export class MySocket {
 *   \@Inject(BaseRequest)
 *   private readonly request: BaseRequest;
 *
 *   \@Hook("verify")
 *   verify(): void {
 *     if (!this.request.getRequestHeader("my-header") === "approved") {
 *       throw new HttpError(403, "You are not approved");
 *     }
 *   }
 *
 *   \@Hook("open")
 *   open(@Inject(Socket) socket: Socket) {
 *   }
 * }
 */
exports.Hook = mapAction("Hook");
//# sourceMappingURL=action.js.map