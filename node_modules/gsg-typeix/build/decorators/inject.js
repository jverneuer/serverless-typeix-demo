"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../core");
const metadata_1 = require("../injector/metadata");
/**
 * @since 1.0.0
 * @decorator
 * @function
 * @name Inject
 *
 * @description
 * Inject is used to define metadata which will be injected at class construct time by Injector
 *
 * @example
 * import {Provider, Inject} from "typeix";
 * import {MyService} form "./services/my-service";
 *
 * \@Provider([MyService])
 * class AssetLoader{
 *    \@Inject(MyService)
 *    private myService;
 * }
 */
exports.Inject = (value, isMutable) => {
    return (Class, key, paramIndex) => {
        let type = "Inject";
        let metadata = [];
        let metadataKey = core_1.isUndefined(paramIndex) ? metadata_1.INJECT_KEYS : metadata_1.FUNCTION_PARAMS;
        if (metadata_1.Metadata.hasMetadata(Class, metadataKey)) {
            metadata = metadata_1.Metadata.getMetadata(Class, metadataKey);
        }
        if (metadata_1.Metadata.isDescriptor(paramIndex)) {
            throw new TypeError(`@${type} is not allowed ${metadata_1.Metadata.getName(Class, "on class ")} on ${paramIndex.value}
      @Inject is allowed only as param type!`);
        }
        else if (core_1.isUndefined(value)) {
            throw new TypeError(`@Inject is not allowed with undefined value ${metadata_1.Metadata.getName(Class, "on ")}.${key}
      - make sure there are no circular dependencies`);
        }
        metadata.push(core_1.isUndefined(paramIndex) ? {
            Class: Class.constructor,
            value,
            isMutable: !!isMutable,
            key
        } : {
            Class: Class.constructor,
            type,
            key,
            value: value,
            paramIndex
        });
        metadata_1.Metadata.defineMetadata(Class, metadataKey, metadata);
        return Class;
    };
};
//# sourceMappingURL=inject.js.map