"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../core");
const metadata_1 = require("../injector/metadata");
const router_1 = require("../router/router");
const logger_1 = require("../logger/logger");
/**
 * Module decorator
 * @decorator
 * @function
 * @name Module
 *
 * @param {IModuleMetadata} config
 * @returns {function(any): any}
 *
 * @description
 * Define module in your application
 *
 * @example
 * import {Module, Router} from "typeix";
 *
 * \@Module({
 *  providers:[Logger, Router]
 * })
 * class Application{
 *    constructor(router: Router) {
 *
 *    }
 * }
 */
exports.Module = (config) => (Class) => {
    if (!core_1.isClass(Class)) {
        throw new TypeError(`@Module is allowed only on class`);
    }
    if (!core_1.isArray(config.providers)) {
        config.providers = [];
    }
    if (!core_1.isArray(config.exports)) {
        config.exports = [];
    }
    if (metadata_1.Metadata.inProviders(config.providers, logger_1.Logger) && !metadata_1.Metadata.inProviders(config.exports, logger_1.Logger)) {
        config.exports.unshift(logger_1.Logger);
    }
    if (metadata_1.Metadata.inProviders(config.providers, router_1.Router) && !metadata_1.Metadata.inProviders(config.exports, router_1.Router)) {
        config.exports.unshift(router_1.Router);
    }
    config.providers = config.providers.map(ProviderClass => metadata_1.Metadata.verifyProvider(ProviderClass));
    metadata_1.Metadata.setComponentConfig(Class, config);
    return Class;
};
//# sourceMappingURL=module.js.map