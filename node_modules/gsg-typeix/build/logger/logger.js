"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const level_1 = require("./level");
const log_1 = require("./log");
const injectable_1 = require("../decorators/injectable");
const core_1 = require("../core");
/**
 * @since 1.0.0
 * @enum
 * @name LogLevels
 */
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["TRACE"] = 10] = "TRACE";
    LogLevels[LogLevels["BENCHMARK"] = 20] = "BENCHMARK";
    LogLevels[LogLevels["DEBUG"] = 30] = "DEBUG";
    LogLevels[LogLevels["INFO"] = 40] = "INFO";
    LogLevels[LogLevels["WARN"] = 60] = "WARN";
    LogLevels[LogLevels["ERROR"] = 80] = "ERROR";
    LogLevels[LogLevels["FATAL"] = 100] = "FATAL";
})(LogLevels = exports.LogLevels || (exports.LogLevels = {}));
/**
 * @since 1.0.0
 * @name Logger
 *
 * @constructor
 * @description
 * Logger is a component in easy node application.
 * Logger handler for easy node, there a various type of logs
 * [INFO, TRACE, DEBUG, WARN, ERROR, FATAL]
 * By default only ERROR and FATAL are enabled in production mode.
 * Logger in system is delivered as component
 * @example
 */
let Logger = class Logger {
    constructor() {
        this.hooks = new Set();
        this.levels = [];
        this.enabled = false;
        this.debugLevel = LogLevels.ERROR;
        this.levels.push(new level_1.Level("TRACE", LogLevels.TRACE, console.info));
        this.levels.push(new level_1.Level("BENCHMARK", LogLevels.BENCHMARK, console.info));
        this.levels.push(new level_1.Level("DEBUG", LogLevels.DEBUG, console.info));
        this.levels.push(new level_1.Level("INFO", LogLevels.INFO, console.info));
        this.levels.push(new level_1.Level("WARN", LogLevels.WARN, console.warn));
        this.levels.push(new level_1.Level("ERROR", LogLevels.ERROR, console.error));
        this.levels.push(new level_1.Level("FATAL", LogLevels.FATAL, console.error));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#isDebugLevel
     *
     * @description
     * Check if is certian log level
     */
    isDebugLevel(logLevel) {
        return core_1.isEqual(this.debugLevel, logLevel);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#setDebugLevel
     *
     * @description
     * Set debug level
     */
    setDebugLevel(value) {
        this.debugLevel = value;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#enable
     *
     * @description
     * enable logger
     */
    enable() {
        this.enabled = true;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#printToConsole
     *
     * @description
     * Print to console logs
     */
    printToConsole() {
        this.levels.forEach((item) => this.addHook((log) => {
            if (log.getLevel() === item.getLevel()) {
                item.exec(log.prettify());
            }
        }));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#trace
     *
     * @description
     * Trace
     */
    trace(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.TRACE));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#info
     *
     * @description
     * Log info case
     */
    info(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.INFO));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#debug
     *
     * @description
     * Debug
     */
    debug(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.DEBUG));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#warn
     *
     * @description
     * Log warn case
     */
    warn(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.WARN));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#benchmark
     *
     * @description
     * Benchmarking pourposes
     */
    benchmark(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.BENCHMARK));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#error
     *
     * @description
     * Log error case
     */
    error(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.ERROR));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#fatal
     *
     * @description
     * Fatal error
     */
    fatal(message, ...args) {
        return this.log(message, args, this.filter(LogLevels.FATAL));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#filter
     * @private
     * @description
     * Get level name
     * This is used internally by logger class
     */
    filter(level) {
        return this.levels.find((item) => {
            return item.getLevel() === level;
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#addHook
     * @param {Function} callback
     *
     * @description
     * Add hook to log output so developer can extend where to store log
     */
    addHook(callback) {
        this.hooks.add(callback);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Logger#log
     * @private
     * @description
     * Write to file and exec hooks
     */
    log(message, data, level) {
        if (!this.enabled || level.getLevel() < this.debugLevel) {
            return false;
        }
        this.hooks.forEach(hook => hook(new log_1.Log(message, data, level)));
        return true;
    }
};
Logger = __decorate([
    injectable_1.Injectable(),
    __metadata("design:paramtypes", [])
], Logger);
exports.Logger = Logger;
//# sourceMappingURL=logger.js.map