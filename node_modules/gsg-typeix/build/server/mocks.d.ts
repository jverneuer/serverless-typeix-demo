/// <reference types="node" />
import { Injector } from "../injector/injector";
import { IModule } from "../interfaces/imodule";
import { IProvider } from "../interfaces/iprovider";
import * as WebSocket from "ws";
export interface IFakeServerConfig {
}
/**
 * @since 1.0.0
 * @function
 * @name fakeHttpServer
 * @param {Function} Class httpServer class
 * @param {IFakeServerConfig} config fakeHttpServer config
 * @returns {Injector}
 *
 * @description
 * Use fakeHttpServer for testing only
 */
export declare function fakeHttpServer(Class: Function, config?: IFakeServerConfig): FakeServerApi;
/**
 * @since 1.0.0
 * @function
 * @name fakeControllerActionCall
 * @param {Injector} injector
 * @param {Function | IProvider} controller
 * @param {String} action name to fire action
 * @param {Object} params
 * @param {Object} headers
 *
 * @returns {Promise<string|Buffer>}
 *
 * @description
 * Use fakeControllerCall for testing only
 */
export declare function fakeControllerActionCall(injector: Injector, controller: Function | IProvider, action: string, params?: Object, headers?: Object): Promise<string | Buffer>;
/**
 * @since 1.0.0
 * @class
 * @name FakeResponseApi
 * @constructor
 * @description
 * FakeResponseApi api
 *
 * @private
 */
export interface FakeResponseApi {
    getStatusCode(): number;
    getBody(): string | Buffer;
    getHeaders(): any;
}
/**
 * @since 2.0.0
 * @interface
 * @name FakeWebSocketApi
 *
 * @description
 * API used to communicate with a fake WebSocket during testing.
 */
export interface FakeWebSocketApi {
    /**
     * @since 2.0.0
     * @function
     * @name FakeWebSocketApi#open
     * @return {Promise<void>} Resolved when the socket is ready, rejected on error
     *
     * @description
     * Opens and prepares the fake socket for usage.
     * You need to call open before receiving or sending data.
     */
    open(): Promise<void>;
    /**
     * @since 2.0.0
     * @function
     * @name FakeWebSocketApi#close
     *
     * @description
     * Closes the fake socket.
     */
    close(): void;
    /**
     * @since 2.0.0
     * @function
     * @name FakeWebSocketApi#send
     * @param {"ws".Data} data Data to send
     *
     * @description
     * Send data over the fake websocket
     */
    send(data: WebSocket.Data): void;
    /**
     * @since 2.0.0
     * @function
     * @name FakeWebSocketApi#getLastReceivedMessage
     * @return {any} The data that was last received over the socket
     *
     * @description
     * Get the last message that had been received via the socket from the server.
     */
    getLastReceivedMessage(): any;
    /**
     * @since 2.0.0
     * @function
     * @name FakeWebSocketApi#onMessage
     * @param {(message: any) => void} cb
     *
     * @description
     * Register a listener to be called whenever a message is sent from the server.
     */
    onMessage(cb: (message: any) => void): any;
}
/**
 * @since 1.0.0
 * @class
 * @name FakeServerApi
 * @constructor
 * @description
 * Get a FakeServerApi to do serverside requests
 *
 * @private
 */
export declare class FakeServerApi {
    private modules;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#getModules
     * @description
     * Get initialized modules
     */
    getModules(): Array<IModule>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#GET
     * @description
     * Fire GET Method
     */
    GET(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#OPTIONS
     * @description
     * Fire OPTIONS Method
     */
    OPTIONS(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#HEAD
     * @description
     * Fire HEAD Method
     */
    HEAD(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#DELETE
     * @description
     * Fire DELETE Method
     */
    DELETE(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#TRACE
     * @description
     * Fire TRACE Method
     */
    TRACE(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#CONNECT
     * @description
     * Fire CONNECT Method
     */
    CONNECT(url: string, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#POST
     * @description
     * Fire POST Method
     */
    POST(url: string, data?: string | Buffer, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#PUT
     * @description
     * Fire PUT Method
     */
    PUT(url: string, data?: string | Buffer, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#PATCH
     * @description
     * Fire PATCH Method
     */
    PATCH(url: string, data?: string | Buffer, headers?: Object): Promise<FakeResponseApi>;
    /**
     * @since 2.0.0
     * @function
     * @name FakeServerApi#createSocket
     * @return {Promise<FakeWebSocketApi>} Promise that will resolve if the socket has been verified or rejected otherwise
     *
     * @description
     * Create a fake WebSocket connection. This will trigger the regular resolution process and will try to verify the socket.
     * If verification fails the returned promise will be rejected otherwise it will be resolved and you can use the
     * {@link FakeWebSocketApi} to simulate data exchange.
     */
    createSocket(url: string, headers?: Object): Promise<FakeWebSocketApi>;
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#request
     * @private
     * @description
     * Fire request
     */
    private request;
}
