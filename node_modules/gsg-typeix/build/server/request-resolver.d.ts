/// <reference types="node" />
import { IAfterConstruct, IProvider } from "../interfaces/iprovider";
import { IncomingMessage } from "http";
import { Logger } from "../logger/logger";
import { Router } from "../router/router";
import { Url } from "url";
import { IModule, IResolvedModule } from "../interfaces/imodule";
import { IResolvedRoute } from "../interfaces/iroute";
import { HttpError } from "../error";
import { Injector } from "../injector/injector";
import { SocketResolver } from "./socket-resolver";
export declare const MODULE_KEY = "__module__";
export declare const ERROR_KEY = "__error__";
/**
 * @since 2.0.0
 * @private
 * @abstract
 * @class
 * @name BaseRequestResolver
 *
 * @description
 * Base class for all kinds of request resolvers providing the general functionality
 */
export declare abstract class BaseRequestResolver {
    /**
     * @param IncomingMessage
     * @description
     * The current request being processed
     */
    protected readonly request: IncomingMessage;
    /**
     * @param {Injector} injector
     * @description
     * Current injector
     */
    protected readonly injector: Injector;
    /**
     * @param {Logger} logger
     * @description
     * Provided by injector
     */
    protected readonly logger: Logger;
    /**
     * @param {Router} router
     * @description
     * Provided by injector
     */
    protected readonly router: Router;
    /**
     * @param {Array<Buffer>} data
     * @description
     * Data received by client on POST, PATCH, PUT requests
     */
    protected readonly data: Array<Buffer>;
    /**
     * @param {string} id
     * @description
     * UUID identifier of request
     */
    protected readonly id: string;
    /**
     * @param {Url} url
     * @description
     * Parsed request url
     */
    protected readonly url: Url;
    /**
     * @param {Url} url
     * @description
     * Parsed request url
     */
    protected readonly modules: Array<IModule>;
    /**
     * @since 1.0.0
     * @function
     * @name BaseRequestResolver#process
     * @private
     * @description
     * Resolves route and resolves module before processing the module
     */
    process(): Promise<any>;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name BaseRequestResolver#processModule
     * @param {IResolvedModule} resolvedModule
     * @return {Promise<any>} Promise to resolve when processing is finished, reject on error
     *
     * @description
     * Called when the resolved module is to be processed
     */
    abstract processModule(resolvedModule: IResolvedModule): Promise<any>;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name BaseRequestResolver#handleError
     * @param {any} data Any error or data a promise during processing had been rejected
     *
     * @description
     * Called when an error occurs during processing - do recovery or other error handling in concrete implementation
     */
    protected abstract handleError(data: any): void;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#getResolvedModule
     * @param {IResolvedRoute} resolvedRoute The resolved route
     * @return {IResolvedModule} The module belonging to the resolved route
     *
     * @description
     * Resolve route and return the corresponding resolved module as well as controller and action (if available)
     */
    protected getResolvedModule(resolvedRoute: IResolvedRoute): IResolvedModule;
}
/**
 * @since 1.0.0
 * @enum
 * @name Renderer
 * @description
 * RenderType types
 *
 * @private
 */
export declare enum RenderType {
    REDIRECT = 0,
    DATA_HANDLER = 1,
    CUSTOM_ERROR_HANDLER = 2,
    DEFAULT_ERROR_HANDLER = 3
}
/**
 * @since 2.0.0
 * @private
 * @class
 * @constructor
 * @name HttpRequestResolver
 *
 * @description
 * Does request resolution for regular HTTP requests
 */
export declare class HttpRequestResolver extends BaseRequestResolver implements IAfterConstruct {
    /**
     * @param ServerResponse
     * @description
     * Value provided by injector which handles response output
     */
    private readonly response;
    /**
     * @param {Number} statusCode
     * @description
     * ControllerResolver status code default 200
     */
    private statusCode;
    /**
     * @param {String} contentType
     * @description
     * Content type
     */
    private contentType;
    /**
     * @param {EventEmitter} eventEmitter
     * @description
     * Responsible for handling events
     */
    private readonly eventEmitter;
    /**
     * @param {String} redirectTo
     * @description
     * Set redirect to
     */
    private redirectTo;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#getControllerProvider
     * @param {IResolvedModule} resolvedModule The resolved module
     *
     * @description
     * Returns a controller provider
     */
    static getControllerProvider(resolvedModule: IResolvedModule): IProvider;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#afterConstruct
     *
     * @description
     * Create event listeners for status code and content type change
     */
    afterConstruct(): void;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#processError
     * @param {Object} data
     * @param {boolean} isCustom
     * @return {Promise<Buffer|string>} Promise to be resolved when error handling was successful
     *
     * @description
     * Process error handling
     * @todo fix custom error handling
     */
    processError(data: any, isCustom: boolean): Promise<Buffer | string>;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#render
     * @param {Buffer|String} response The produced response so far
     * @param {RenderType} type How to render the response
     *
     * @description
     * Renders the given response and transfers the final data to the client
     */
    render(response: string | Buffer, type: RenderType): Promise<string | Buffer>;
    /**
     * @inheritDoc
     */
    processModule(resolvedModule: IResolvedModule, error?: HttpError): Promise<string | Buffer>;
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#handleError
     * @param {any} data Any error or data a promise during processing had been rejected
     *
     * @description
     * Tries to render the data using a custom registered error handler or falls back to default error rendering.
     */
    protected handleError(data: any): void;
}
/**
 * @since 2.0.0
 * @private
 * @class
 * @name SocketRequestResolver
 * @constructor
 *
 * @description
 * Handles the current request and resolves to a socket
 */
export declare class SocketRequestResolver extends BaseRequestResolver {
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketRequestResolver#getSocketProvider
     * @param {IResolvedModule} resolvedModule The resolved module to make into a socket
     * @return {IProvider} The designated {@link WebSocket} provider
     *
     * @description
     * This method tries to find the designated {@link WebSocket} for the given resolved module.
     */
    static getSocketProvider(resolvedModule: IResolvedModule): IProvider;
    /**
     * @inheritDoc
     */
    processModule(resolvedModule: IResolvedModule): Promise<SocketResolver>;
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketRequestResolver#handleError
     * @param {any} data Any error or data a promise during processing had been rejected
     *
     * @description
     * Logs the error and throws an {@link HttpError} to indicate that it's not possible
     * to resolve to a socket.
     */
    protected handleError(data: any): void;
}
