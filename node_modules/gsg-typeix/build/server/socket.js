"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../logger/logger");
const request_resolver_1 = require("./request-resolver");
const core_1 = require("../core");
const injector_1 = require("../injector/injector");
const status_code_1 = require("./status-code");
const bootstrap_1 = require("./bootstrap");
const url_1 = require("url");
const events_1 = require("events");
const error_1 = require("../error");
/**
 * @since 2.0.0
 * @class
 * @constructor
 * @name Socket
 *
 * @description
 * Basic API for accessing a WebSocket in order to get state information, send data, or close the socket.
 */
class Socket {
    /**
     * @since 2.0.0
     * @param {WebSocket} ws Underlying WebSocket to wrap
     *
     * @description
     * Creates a new API wrapping the given raw WebSocket
     */
    constructor(ws) {
        this.ws = ws;
    }
    /**
     * @since 2.0.0
     * @function
     * @name Socket#getReadyState
     * @return {number} Socket readyState
     *
     * @description
     * Get the underlying WebSocket's readyState (see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants)
     */
    getReadyState() {
        return this.ws.readyState;
    }
    /**
     * @since 2.0.0
     * @function
     * @name Socket#close
     * @param {number} status Status code to send as close reason
     * @param {string} data Data to send as close reason
     *
     * @description
     * Closes the underlying WebSocket
     */
    close(status, data) {
        this.ws.close(status, data);
    }
    /**
     * @since 2.0.0
     * @function
     * @name Socket#send
     * @param data Data to send to the client
     * @param {{mask?: boolean; binary?: boolean}|(err: Error) => void} options Either send options or the error callback
     * @param {(err: Error) => void} cb (only if second parameter are options) error callback
     */
    send(data, options, cb) {
        this.ws.send(data, options, cb);
    }
}
exports.Socket = Socket;
/**
 * @since 2.0.0
 * @function
 * @name fireWebSocket
 * @param {Array<IModule>} modules Bootstrapped modules
 * @param {"http".IncomingMessage} request Incoming HTTP request
 * @return {Promise<IWebSocketResult>} Promise which will resolve once the socket has been verified or reject on failure
 *
 * @description
 * This method will trigger a WebSocket resolution and will try to find a matching {@link WebSocket} registered in the system.
 * Typically you do not use this method directly but it is called automatically by the framework. For testing best
 * refer to {@link FakeServerApi#createSocket}.
 */
function fireWebSocket(modules, request) {
    let rootInjector = bootstrap_1.getModule(modules).injector;
    let logger = rootInjector.get(logger_1.Logger);
    const requestUuid = core_1.uuid();
    /**
     * Create SocketRequestResolver injector
     */
    let socketResolverInjector = injector_1.Injector.createAndResolveChild(rootInjector, request_resolver_1.SocketRequestResolver, [
        { provide: "url", useValue: url_1.parse(request.url, true) },
        { provide: "UUID", useValue: requestUuid },
        { provide: "data", useValue: [] },
        { provide: "request", useValue: request },
        { provide: "modules", useValue: modules },
        events_1.EventEmitter
    ]);
    const socketResolver = socketResolverInjector.get(request_resolver_1.SocketRequestResolver);
    logger.debug("Resolved SocketRequestResolver - starting processing", { request });
    return socketResolver
        .process()
        .then((socket) => {
        logger.debug("socketResolver.then result:", { socket });
        if (!core_1.isPresent(socket)) {
            throw new error_1.HttpError(status_code_1.Status.Internal_Server_Error, "Could not resolve socket");
        }
        else {
            const result = {
                uuid: requestUuid,
                open: (ws) => {
                    logger.info("Resuming request", { uuid: requestUuid });
                    return socket.openSocket(ws);
                },
                finished: () => {
                    socket.destroy();
                    socketResolverInjector.destroy();
                }
            };
            return result;
        }
    })
        .catch((error) => {
        logger.error("fireWebSocket: Failed to create socket", { error });
        return {
            uuid: requestUuid,
            error: error,
            finished: () => {
                socketResolverInjector.destroy();
            }
        };
    });
}
exports.fireWebSocket = fireWebSocket;
//# sourceMappingURL=socket.js.map