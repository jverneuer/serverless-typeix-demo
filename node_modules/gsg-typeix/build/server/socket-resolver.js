"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const core_1 = require("../core");
const logger_1 = require("../logger/logger");
const injector_1 = require("../injector/injector");
const events_1 = require("events");
const decorators_1 = require("../decorators");
const metadata_1 = require("../injector/metadata");
const request_1 = require("./request");
const controller_resolver_1 = require("./controller-resolver");
const socket_1 = require("./socket");
/**
 * @since 2.0.0
 * @private
 * @class
 * @name SocketResolver
 * @constructor
 *
 * @description
 * This component is responsible for finding and instantiating the correctly annotated {@link WebSocket} class
 * in the application. It is used internally by the framework.
 */
let SocketResolver = class SocketResolver {
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getEventEmitter
     *
     * @description
     * Get request event emitter
     */
    getEventEmitter() {
        return this.eventEmitter;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getIncomingMessage
     *
     * @description
     * Get underlying upgrade request
     */
    getIncomingMessage() {
        return this.request;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getResolvedRoute
     *
     * @description
     * Get originally resolved route
     */
    getResolvedRoute() {
        return this.resolvedRoute;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getId
     *
     * @description
     * Get unique request ID
     */
    getId() {
        return this.id;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getBody
     *
     * @description
     * Get the data sent with the upgrade request
     */
    getBody() {
        return this.data;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#destroy
     *
     * @description
     * Destroy all references to free memory
     */
    destroy() {
        if (core_1.isPresent(this.socket) && core_1.isFunction(this.socket.afterClose)) {
            this.socket.afterClose();
        }
        this.eventEmitter.emit("destroy");
        this.eventEmitter.removeAllListeners();
        this.socket = null;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#process
     * @return {Promise<SocketResolver>} Promise to resolve when the socket was created and verified successfully
     *
     * @description
     * Process request logic by creating and verifying the socket
     */
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            // set request reflection
            const reflectionInjector = injector_1.Injector.createAndResolveChild(this.injector, request_1.BaseRequest, [
                { provide: "data", useValue: this.data },
                { provide: "request", useValue: this.request },
                { provide: "UUID", useValue: this.id },
                { provide: "resolvedRoute", useValue: this.resolvedRoute }
            ]);
            const metadata = metadata_1.Metadata.getComponentConfig(this.socketProvider.provide);
            const providers = metadata_1.Metadata.verifyProviders(metadata.providers);
            // limit socket api
            const limitApi = ["request", "response", "modules"];
            limitApi.forEach(item => providers.push({ provide: item, useValue: {} }));
            const socketInjector = injector_1.Injector.createAndResolveChild(reflectionInjector, this.socketProvider, metadata_1.Metadata.verifyProviders(providers));
            this.socket = socketInjector.get(this.socketProvider.provide);
            yield this.processSocketHook("verify");
            return this;
        });
    }
    /**
     * @sicne 2.0.0
     * @function
     * @name SocketResolver#openSocket
     * @param {WebSocket} ws The "ws".WebSocket representing the real socket
     * @return {Promise<any>} Promise to resolve when the socket has been opened successfully
     *
     * @description
     * Tries to call the open method on the created {@link WebSocket} and sets up message listeners.
     */
    openSocket(ws) {
        return __awaiter(this, void 0, void 0, function* () {
            this.injector.set(socket_1.Socket, new socket_1.Socket(ws));
            ws.on("message", (data) => {
                this.injector.set("message", data);
                this.processSocketHook("message");
            });
            this.processSocketHook("open");
        });
    }
    /**
     * @since 2.0.0
     * @function
     * @name SocketResolver#processSocketHook
     * @param {string} actionName Name of the {@link Hook} to invoke
     * @return {Promise<any>} Promise resolved when the hook had been invoked successfully
     *
     * @description
     * Tries to invoke the {@link Hook} for the given name on the created socket.
     */
    processSocketHook(actionName) {
        return __awaiter(this, void 0, void 0, function* () {
            const action = this.getMappedHook(this.socketProvider, actionName);
            if (!core_1.isPresent(action) || !core_1.isFunction(this.socket[action.key])) {
                this.logger.debug("Tried to call socket @Hook but not available", {
                    hook: actionName
                });
                return;
            }
            const func = this.socket[action.key].bind(this.socket);
            const args = this.getAnnotatedArguments(this.socketProvider, action.key);
            return yield func.apply(this.socket, args);
        });
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getMappedHook
     * @param {IProvider} socketProvider The provider of the socket
     * @param {String} actionName The hook name to call
     * @return {IAction} The action representing the hook
     *
     * @description
     * Investigates the metadata of the given provider to find the action representing the hook with the given name.
     */
    getMappedHook(socketProvider, actionName) {
        // get mappings from controller
        let mappings = metadata_1.Metadata
            .getMetadata(this.socketProvider.provide.prototype, metadata_1.FUNCTION_KEYS)
            .filter((item) => item.type === "Hook" && item.value === actionName &&
            controller_resolver_1.ControllerResolver.isControllerInherited(this.socketProvider.provide, item.proto));
        let mappedAction;
        // search mapped on current controller
        if (mappings.length > 0) {
            mappedAction = mappings.find(item => item.className === metadata_1.Metadata.getName(socketProvider.provide));
        }
        // get first parent one from inheritance
        if (!core_1.isPresent(mappedAction)) {
            mappedAction = mappings.pop();
        }
        return mappedAction;
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketResolver#getAnnotatedArguments
     * @param {IProvider} provider The socket provider
     * @param {string} functionName The name of the function to get argument information for
     * @return {Array<any>} The values to use as arguments
     *
     * @description
     * Inspects the given function of the provider and returns the correct argument values
     */
    getAnnotatedArguments(provider, functionName) {
        const params = metadata_1.Metadata
            .getMetadata(provider.provide.prototype, metadata_1.FUNCTION_PARAMS)
            .filter((param) => param.key === functionName);
        return params
            .sort((p1, p2) => p1.paramIndex - p2.paramIndex)
            .map((param) => {
            switch (param.type) {
                case "Param":
                    if (core_1.isPresent(this.resolvedRoute.params) && this.resolvedRoute.params.hasOwnProperty(param.value)) {
                        return this.resolvedRoute.params[param.value];
                    }
                    else {
                        return null;
                    }
                case "Inject":
                    return this.injector.get(param.value);
            }
        });
    }
};
__decorate([
    decorators_1.Inject("request"),
    __metadata("design:type", http_1.IncomingMessage)
], SocketResolver.prototype, "request", void 0);
__decorate([
    decorators_1.Inject("data"),
    __metadata("design:type", Array)
], SocketResolver.prototype, "data", void 0);
__decorate([
    decorators_1.Inject("UUID"),
    __metadata("design:type", String)
], SocketResolver.prototype, "id", void 0);
__decorate([
    decorators_1.Inject("socketProvider"),
    __metadata("design:type", Object)
], SocketResolver.prototype, "socketProvider", void 0);
__decorate([
    decorators_1.Inject("resolvedRoute"),
    __metadata("design:type", Object)
], SocketResolver.prototype, "resolvedRoute", void 0);
__decorate([
    decorators_1.Inject(injector_1.Injector),
    __metadata("design:type", injector_1.Injector)
], SocketResolver.prototype, "injector", void 0);
__decorate([
    decorators_1.Inject(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], SocketResolver.prototype, "logger", void 0);
__decorate([
    decorators_1.Inject(events_1.EventEmitter),
    __metadata("design:type", events_1.EventEmitter)
], SocketResolver.prototype, "eventEmitter", void 0);
SocketResolver = __decorate([
    decorators_1.Injectable()
], SocketResolver);
exports.SocketResolver = SocketResolver;
//# sourceMappingURL=socket-resolver.js.map