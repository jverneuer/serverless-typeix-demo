"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var ControllerResolver_1;
const http_1 = require("http");
const router_1 = require("../router/router");
const core_1 = require("../core");
const logger_1 = require("../logger/logger");
const injector_1 = require("../injector/injector");
const events_1 = require("events");
const error_1 = require("../error");
const injectable_1 = require("../decorators/injectable");
const inject_1 = require("../decorators/inject");
const metadata_1 = require("../injector/metadata");
const status_code_1 = require("./status-code");
const request_1 = require("./request");
const request_resolver_1 = require("./request-resolver");
const CHAIN_KEY = "__chain__";
/**
 * @since 1.0.0
 * @class
 * @name Request
 * @constructor
 * @description
 * ControllerResolver is responsible for handling router result and processing all requests in system
 * This component is used internally by framework
 *
 * @private
 */
let ControllerResolver = ControllerResolver_1 = class ControllerResolver {
    /**
     * @since 1.0.0
     * @function
     * @name Request#isControllerPrototypeOf
     * @private
     * @description
     * Validate controller inheritance
     */
    static isControllerInherited(a, b) {
        return b.isPrototypeOf(a.prototype) || Object.is(a.prototype, b);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#stopChain
     * @private
     * @description
     * Stop action chain
     */
    stopChain() {
        this.isChainStopped = true;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#destroy
     * @private
     * @description
     * Destroy all references to free memory
     */
    destroy() {
        this.eventEmitter.emit("destroy");
        this.eventEmitter.removeAllListeners();
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getEventEmitter
     * @private
     *
     * @description
     * Get request event emitter
     */
    getEventEmitter() {
        return this.eventEmitter;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getIncomingMessage
     * @private
     *
     * @description
     * Get IncomingMessage object
     */
    getIncomingMessage() {
        return this.request;
    }
    getResolvedRoute() {
        return this.resolvedRoute;
    }
    getId() {
        return this.id;
    }
    getBody() {
        return this.data;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getServerResponse
     * @private
     *
     * @description
     * Get ServerResponse object
     */
    getServerResponse() {
        return this.response;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#process
     * @private
     * @description
     * Process request logic
     */
    process() {
        // destroy on end
        this.response.once("finish", () => this.destroy());
        // destroy if connection was terminated before end
        this.response.once("close", () => this.destroy());
        // set request reflection
        const reflectionInjector = injector_1.Injector.createAndResolveChild(this.injector, request_1.Request, [
            { provide: "controllerResolver", useValue: this }
        ]);
        return this.processController(reflectionInjector, this.controllerProvider, this.actionName);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#hasMappedAction
     * @private
     * @description
     * Check if controller has mapped action
     */
    hasMappedAction(controllerProvider, actionName, name = "Action") {
        let mappings = metadata_1.Metadata.getMetadata(controllerProvider.provide.prototype, metadata_1.FUNCTION_KEYS)
            .filter((item) => ControllerResolver_1.isControllerInherited(controllerProvider.provide, item.proto));
        return core_1.isPresent(mappings.find(item => item.type === name && item.value === actionName));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getMappedHook
     * @private
     * @description
     * Returns a mapped action metadata
     */
    getMappedAction(controllerProvider, actionName, name = "Action") {
        // get mappings from controller
        let mappings = metadata_1.Metadata
            .getMetadata(controllerProvider.provide.prototype, metadata_1.FUNCTION_KEYS)
            .filter((item) => item.type === name && item.value === actionName &&
            ControllerResolver_1.isControllerInherited(controllerProvider.provide, item.proto));
        let mappedAction;
        // search mapped on current controller
        if (mappings.length > 0) {
            mappedAction = mappings.find(item => item.className === metadata_1.Metadata.getName(controllerProvider.provide));
        }
        // get first parent one from inheritance
        if (!core_1.isPresent(mappedAction)) {
            mappedAction = mappings.pop();
        }
        // check if action is present
        if (!core_1.isPresent(mappedAction)) {
            throw new error_1.HttpError(status_code_1.Status.Bad_Request, `@${name}("${actionName}") is not defined on controller ${metadata_1.Metadata.getName(controllerProvider.provide)}`, {
                actionName,
                name,
                resolvedRoute: this.resolvedRoute
            });
        }
        return mappedAction;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getDecoratorByMappedAction
     * @private
     * @description
     * Get param decorator by mapped action
     */
    getDecoratorByMappedAction(controllerProvider, mappedAction, paramName) {
        // get mappings from controller
        let mappings = metadata_1.Metadata.getMetadata(controllerProvider.provide.prototype, metadata_1.FUNCTION_KEYS);
        return mappings.find((item) => item.type === paramName && item.key === mappedAction.key &&
            ControllerResolver_1.isControllerInherited(controllerProvider.provide, item.proto));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getMappedActionArguments
     * @private
     * @description
     * Get list of action arguments
     */
    getMappedActionArguments(controllerProvider, mappedAction) {
        // get mappings from controller
        let mappings = metadata_1.Metadata.getMetadata(controllerProvider.provide.prototype, metadata_1.FUNCTION_PARAMS);
        return mappings.filter((item) => item.key === mappedAction.key);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#processAction
     * @private
     * @description
     * Process mapped action
     */
    processAction(injector, controllerProvider, mappedAction) {
        // get controller instance
        let controllerInstance = injector.get(controllerProvider.provide);
        // get action
        let action = controllerInstance[mappedAction.key].bind(controllerInstance);
        // content type
        let contentType = this.getDecoratorByMappedAction(controllerProvider, mappedAction, "Produces");
        if (core_1.isPresent(contentType)) {
            this.getEventEmitter().emit("contentType", contentType.value);
        }
        // resolve action params
        let actionParams = [];
        let params = this.getMappedActionArguments(controllerProvider, mappedAction);
        if (core_1.isPresent(params)) {
            // make sure params are sorted correctly :)
            params.sort((a, b) => {
                if (a.paramIndex > b.paramIndex) {
                    return 1;
                }
                else if (a.paramIndex < b.paramIndex) {
                    return -1;
                }
                return 0;
            });
            // push action params
            params.forEach(param => {
                switch (param.type) {
                    case "Param":
                        if (core_1.isPresent(this.resolvedRoute.params) && this.resolvedRoute.params.hasOwnProperty(param.value)) {
                            actionParams.push(this.resolvedRoute.params[param.value]);
                        }
                        else {
                            actionParams.push(null);
                        }
                        break;
                    case "Chain":
                        actionParams.push(injector.get(CHAIN_KEY));
                        break;
                    case "Inject":
                        actionParams.push(injector.get(param.value));
                        break;
                    case "ErrorMessage":
                        actionParams.push(injector.get(request_resolver_1.ERROR_KEY));
                        break;
                }
            });
        }
        return action.apply(controllerInstance, actionParams);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#processControllerFilters
     * @private
     * @description
     * Process controller filters
     */
    processFilters(injector, metadata, isAfter) {
        return __awaiter(this, void 0, void 0, function* () {
            let filters = metadata.filters.filter(item => {
                let filterMetadata = metadata_1.Metadata.getComponentConfig(item);
                if (core_1.isPresent(filterMetadata)) {
                    return (filterMetadata.route === "*" ||
                        filterMetadata.route === this.resolvedRoute.route ||
                        filterMetadata.route === (metadata.name + "/*"));
                }
                return false;
            })
                .sort((aItem, bItem) => {
                let a = metadata_1.Metadata.getComponentConfig(aItem);
                let b = metadata_1.Metadata.getComponentConfig(bItem);
                if (a.priority > b.priority) {
                    return -1;
                }
                else if (a.priority < b.priority) {
                    return 1;
                }
                return 0;
            });
            for (let Class of filters) {
                let filterInjector = injector_1.Injector.createAndResolveChild(injector, Class, []);
                let filter = filterInjector.get(Class);
                if (core_1.isFalsy(this.isChainStopped)) {
                    if (!isAfter) {
                        let start = Date.now();
                        let result = yield filter.before(injector.get(CHAIN_KEY));
                        injector.set(CHAIN_KEY, result);
                        this.benchmark(`Filter.before: ${metadata_1.Metadata.getName(filter, "on filter ")}`, start);
                    }
                    else {
                        let start = Date.now();
                        let result = yield filter.after(injector.get(CHAIN_KEY));
                        injector.set(CHAIN_KEY, result);
                        this.benchmark(`Filter.after: ${metadata_1.Metadata.getName(filter, "on filter ")}`, start);
                    }
                }
                filterInjector.destroy();
            }
            return yield injector.get(CHAIN_KEY);
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#processController
     * @private
     * @description
     * Handle controller instance
     */
    processController(reflectionInjector, controllerProvider, actionName) {
        return __awaiter(this, void 0, void 0, function* () {
            // get controller metadata
            let metadata = metadata_1.Metadata.getComponentConfig(controllerProvider.provide);
            let providers = metadata_1.Metadata.verifyProviders(metadata.providers);
            // limit controller api
            let limitApi = ["request", "response", "controllerProvider", "modules"];
            limitApi.forEach(item => providers.push({ provide: item, useValue: {} }));
            // benchmark
            let requestStart = Date.now();
            // create controller injector
            let injector = new injector_1.Injector(reflectionInjector, [CHAIN_KEY]);
            // initialize controller
            injector.createAndResolve(controllerProvider, metadata_1.Metadata.verifyProviders(providers));
            // set default chain key
            injector.set(CHAIN_KEY, null);
            // process filters
            if (core_1.isArray(metadata.filters)) {
                // set filter result
                injector.set(CHAIN_KEY, yield this.processFilters(injector, metadata, false));
            }
            // process @BeforeEach action
            if (this.hasMappedAction(controllerProvider, null, "BeforeEach") && core_1.isFalsy(this.isChainStopped)) {
                let start = Date.now();
                let result = yield this.processAction(injector, controllerProvider, this.getMappedAction(controllerProvider, null, "BeforeEach"));
                injector.set(CHAIN_KEY, result);
                this.benchmark("BeforeEach", start);
            }
            // process @Before action
            if (this.hasMappedAction(controllerProvider, actionName, "Before") && core_1.isFalsy(this.isChainStopped)) {
                let start = Date.now();
                let result = yield this.processAction(injector, controllerProvider, this.getMappedAction(controllerProvider, actionName, "Before"));
                injector.set(CHAIN_KEY, result);
                this.benchmark("Before", start);
            }
            // Action
            if (core_1.isFalsy(this.isChainStopped)) {
                let start = Date.now();
                let result = yield this.processAction(injector, controllerProvider, this.getMappedAction(controllerProvider, actionName));
                injector.set(CHAIN_KEY, result);
                this.benchmark("Action", start);
            }
            // process @After action
            if (this.hasMappedAction(controllerProvider, actionName, "After") && core_1.isFalsy(this.isChainStopped)) {
                let start = Date.now();
                let result = yield this.processAction(injector, controllerProvider, this.getMappedAction(controllerProvider, actionName, "After"));
                injector.set(CHAIN_KEY, result);
                this.benchmark("After", start);
            }
            // process @AfterEach action
            if (this.hasMappedAction(controllerProvider, null, "AfterEach") && core_1.isFalsy(this.isChainStopped)) {
                let start = Date.now();
                let result = yield this.processAction(injector, controllerProvider, this.getMappedAction(controllerProvider, null, "AfterEach"));
                injector.set(CHAIN_KEY, result);
                this.benchmark("AfterEach", start);
            }
            if (core_1.isFalsy(this.isChainStopped) && core_1.isArray(metadata.filters)) {
                // set filter result
                injector.set(CHAIN_KEY, yield this.processFilters(injector, metadata, true));
            }
            this.benchmark("Request", requestStart);
            // render action call
            return yield injector.get(CHAIN_KEY);
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#benchmark
     * @private
     * @description
     * Print benchmark
     */
    benchmark(message, start) {
        this.logger.benchmark(`${message}: ${(Date.now() - start)}ms`, {
            method: router_1.getMethodName(this.resolvedRoute.method),
            route: this.resolvedRoute.route,
            url: this.request.url
        });
    }
};
__decorate([
    inject_1.Inject("request"),
    __metadata("design:type", http_1.IncomingMessage)
], ControllerResolver.prototype, "request", void 0);
__decorate([
    inject_1.Inject("response"),
    __metadata("design:type", http_1.ServerResponse)
], ControllerResolver.prototype, "response", void 0);
__decorate([
    inject_1.Inject("data"),
    __metadata("design:type", Array)
], ControllerResolver.prototype, "data", void 0);
__decorate([
    inject_1.Inject(injector_1.Injector),
    __metadata("design:type", injector_1.Injector)
], ControllerResolver.prototype, "injector", void 0);
__decorate([
    inject_1.Inject(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], ControllerResolver.prototype, "logger", void 0);
__decorate([
    inject_1.Inject(events_1.EventEmitter),
    __metadata("design:type", events_1.EventEmitter)
], ControllerResolver.prototype, "eventEmitter", void 0);
__decorate([
    inject_1.Inject("UUID"),
    __metadata("design:type", String)
], ControllerResolver.prototype, "id", void 0);
__decorate([
    inject_1.Inject("url"),
    __metadata("design:type", Object)
], ControllerResolver.prototype, "url", void 0);
__decorate([
    inject_1.Inject("controllerProvider"),
    __metadata("design:type", Object)
], ControllerResolver.prototype, "controllerProvider", void 0);
__decorate([
    inject_1.Inject("actionName"),
    __metadata("design:type", String)
], ControllerResolver.prototype, "actionName", void 0);
__decorate([
    inject_1.Inject("isChainStopped", true),
    __metadata("design:type", Boolean)
], ControllerResolver.prototype, "isChainStopped", void 0);
__decorate([
    inject_1.Inject("resolvedRoute"),
    __metadata("design:type", Object)
], ControllerResolver.prototype, "resolvedRoute", void 0);
ControllerResolver = ControllerResolver_1 = __decorate([
    injectable_1.Injectable()
], ControllerResolver);
exports.ControllerResolver = ControllerResolver;
//# sourceMappingURL=controller-resolver.js.map