"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const injector_1 = require("../injector/injector");
const bootstrap_1 = require("./bootstrap");
const metadata_1 = require("../injector/metadata");
const inject_1 = require("../decorators/inject");
const stream_1 = require("stream");
const core_1 = require("../core");
const controller_resolver_1 = require("./controller-resolver");
const request_resolver_1 = require("./request-resolver");
const events_1 = require("events");
const error_1 = require("../error");
const router_1 = require("../router/router");
const logger_1 = require("../logger/logger");
const socket_1 = require("./socket");
/**
 * @since 1.0.0
 * @function
 * @name fakeHttpServer
 * @param {Function} Class httpServer class
 * @param {IFakeServerConfig} config fakeHttpServer config
 * @returns {Injector}
 *
 * @description
 * Use fakeHttpServer for testing only
 */
function fakeHttpServer(Class, config) {
    let metadata = metadata_1.Metadata.getComponentConfig(Class);
    // override bootstrap module
    metadata.name = bootstrap_1.BOOTSTRAP_MODULE;
    // set module config
    metadata_1.Metadata.setComponentConfig(Class, metadata);
    let modules = bootstrap_1.createModule(Class);
    let fakeServerInjector = injector_1.Injector.createAndResolve(FakeServerApi, [
        { provide: "modules", useValue: modules }
    ]);
    return fakeServerInjector.get(FakeServerApi);
}
exports.fakeHttpServer = fakeHttpServer;
/**
 * @since 1.0.0
 * @function
 * @name fakeControllerActionCall
 * @param {Injector} injector
 * @param {Function | IProvider} controller
 * @param {String} action name to fire action
 * @param {Object} params
 * @param {Object} headers
 *
 * @returns {Promise<string|Buffer>}
 *
 * @description
 * Use fakeControllerCall for testing only
 */
function fakeControllerActionCall(injector, controller, action, params, headers) {
    let request = new FakeIncomingMessage();
    request.method = "GET";
    request.headers = core_1.isObject(headers) ? headers : {};
    request.url = "/";
    let response = new FakeServerResponse();
    let controllerProvider = metadata_1.Metadata.verifyProvider(controller);
    let metadata = metadata_1.Metadata.getComponentConfig(controllerProvider.provide);
    let route = {
        method: router_1.Methods.GET,
        params: core_1.isObject(params) ? params : {},
        route: metadata.name + "/" + action
    };
    let providers = [
        { provide: "data", useValue: [] },
        { provide: "request", useValue: request },
        { provide: "response", useValue: response },
        { provide: "url", useValue: request.url },
        { provide: "UUID", useValue: core_1.uuid() },
        { provide: "controllerProvider", useValue: controllerProvider },
        { provide: "actionName", useValue: action },
        { provide: "resolvedRoute", useValue: route },
        { provide: "isForwarded", useValue: false },
        { provide: "isForwarder", useValue: false },
        { provide: "isChainStopped", useValue: false },
        { provide: request_resolver_1.ERROR_KEY, useValue: new error_1.HttpError(500) },
        { provide: events_1.EventEmitter, useValue: new events_1.EventEmitter() }
    ];
    // if there is no logger provide it
    if (!injector.has(logger_1.Logger)) {
        providers.push(metadata_1.Metadata.verifyProvider(logger_1.Logger));
    }
    /**
     * Create and resolve
     */
    let childInjector = injector_1.Injector.createAndResolveChild(injector, controller_resolver_1.ControllerResolver, providers);
    /**
     * On finish destroy injector
     */
    response.on("finish", () => childInjector.destroy());
    /**
     * Get request instance
     * @type {any}
     */
    let pRequest = childInjector.get(controller_resolver_1.ControllerResolver);
    /**
     * Process request
     */
    return pRequest.process();
}
exports.fakeControllerActionCall = fakeControllerActionCall;
/**
 * @since 1.0.0
 * @class
 * @name FakeServerApi
 * @constructor
 * @description
 * Get a FakeServerApi to do serverside requests
 *
 * @private
 */
class FakeServerApi {
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#getModules
     * @description
     * Get initialized modules
     */
    getModules() {
        return this.modules;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#GET
     * @description
     * Fire GET Method
     */
    GET(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "GET";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#OPTIONS
     * @description
     * Fire OPTIONS Method
     */
    OPTIONS(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "OPTIONS";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#HEAD
     * @description
     * Fire HEAD Method
     */
    HEAD(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "HEAD";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#DELETE
     * @description
     * Fire DELETE Method
     */
    DELETE(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "DELETE";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#TRACE
     * @description
     * Fire TRACE Method
     */
    TRACE(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "TRACE";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#CONNECT
     * @description
     * Fire CONNECT Method
     */
    CONNECT(url, headers) {
        let request = new FakeIncomingMessage();
        request.method = "CONNECT";
        request.url = url;
        request.headers = headers;
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#POST
     * @description
     * Fire POST Method
     */
    POST(url, data, headers) {
        let request = new FakeIncomingMessage();
        request.method = "POST";
        request.url = url;
        request.headers = headers;
        // simulate async event
        setTimeout(() => {
            request.emit("data", data);
            request.emit("end");
        });
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#PUT
     * @description
     * Fire PUT Method
     */
    PUT(url, data, headers) {
        let request = new FakeIncomingMessage();
        request.method = "PUT";
        request.url = url;
        request.headers = headers;
        // simulate async event
        setTimeout(() => {
            request.emit("data", data);
            request.emit("end");
        });
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#PATCH
     * @description
     * Fire PATCH Method
     */
    PATCH(url, data, headers) {
        let request = new FakeIncomingMessage();
        request.method = "PATCH";
        request.url = url;
        request.headers = headers;
        // simulate async event
        setTimeout(() => {
            request.emit("data", data);
            request.emit("end");
        });
        return this.request(request, new FakeServerResponse());
    }
    /**
     * @since 2.0.0
     * @function
     * @name FakeServerApi#createSocket
     * @return {Promise<FakeWebSocketApi>} Promise that will resolve if the socket has been verified or rejected otherwise
     *
     * @description
     * Create a fake WebSocket connection. This will trigger the regular resolution process and will try to verify the socket.
     * If verification fails the returned promise will be rejected otherwise it will be resolved and you can use the
     * {@link FakeWebSocketApi} to simulate data exchange.
     */
    createSocket(url, headers) {
        const request = new FakeIncomingMessage();
        request.method = "GET";
        request.url = url;
        request.headers = headers;
        return socket_1.fireWebSocket(this.getModules(), request)
            .then(result => {
            if (result.error || !core_1.isFunction(result.open)) {
                if (result.error instanceof error_1.HttpError) {
                    throw result.error;
                }
                else {
                    throw new Error("socket resolution failed");
                }
            }
            return new FakeWebSocket(result);
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerApi#request
     * @private
     * @description
     * Fire request
     */
    request(request, response) {
        return bootstrap_1.fireRequest(this.getModules(), request, response).then(data => {
            return {
                getBody: () => response.getBody(),
                getHeaders: () => response.getHeaders(),
                getStatusCode: () => response.statusCode
            };
        });
    }
}
__decorate([
    inject_1.Inject("modules"),
    __metadata("design:type", Array)
], FakeServerApi.prototype, "modules", void 0);
exports.FakeServerApi = FakeServerApi;
/**
 * @since 1.0.0
 * @class
 * @name FakeIncomingMessage
 * @constructor
 * @description
 * FakeIncomingMessage is used by FakeServerApi
 * Simulates socket api
 *
 * @private
 */
class FakeIncomingMessage extends stream_1.Readable {
    constructor() {
        super(...arguments);
        this.httpVersion = "1.1";
        this.httpVersionMajor = 1;
        this.httpVersionMinor = 1;
    }
    _read(size) {
        console.log(size);
    }
    setTimeout(msecs, callback) {
        return undefined;
    }
    destroy(error) {
        return null;
    }
}
/**
 * @since 1.0.0
 * @class
 * @name FakeServerResponse
 * @constructor
 * @description
 * FakeServerResponse is used by FakeServerApi
 * Simulates socket api
 *
 * @private
 */
class FakeServerResponse extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.statusCode = 200;
        this.headers = {};
        this.headersSent = false;
        this.finished = false;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#writeContinue
     * @private
     * @description
     * Write continue chunk
     */
    writeContinue() {
        console.log("writeContinue");
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#addTrailers
     * @private
     * @description
     * Add Header Trailers
     */
    addTrailers(headers) {
        console.log(headers);
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#end
     * @private
     * @description
     * End request
     */
    end() {
        this.emit("finish");
        this.finished = true;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#writeHead
     * @private
     * @description
     * Write head
     */
    writeHead(statusCode, headers) {
        this.statusCode = statusCode;
        if (core_1.isObject(headers)) {
            Object.assign(this.headers, headers);
        }
        this.headersSent = true;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#setHeader
     * @private
     * @description
     * Set response header
     */
    setHeader(name, value) {
        this.headers[name] = value;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#getHeader
     * @private
     * @description
     * Get response header
     */
    getHeader(name) {
        if (this.hasHeader(name)) {
            return this.headers[name];
        }
        return null;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#hasHeader
     * @private
     * @description
     * Has header
     */
    hasHeader(name) {
        return this.headers.hasOwnProperty(name);
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#getHeaderNames
     * @private
     * @description
     * Get header names
     */
    getHeaderNames() {
        return Object.keys(this.headers);
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#removeHeader
     * @private
     * @description
     * Remove response header
     */
    removeHeader(name) {
        if (this.headers.hasOwnProperty(name)) {
            delete this.headers[name];
        }
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#getHeaders
     * @private
     * @description
     * Get headers
     */
    getHeaders() {
        return this.headers;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#getBody
     * @private
     * @description
     * Get writed body
     */
    getBody() {
        return this.message;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#getBody
     * @private
     * @description
     * Get writed body
     */
    getStatusCode() {
        return this.statusCode;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#write
     * @private
     * @description
     * Write data
     */
    write(value, encoding, cb) {
        this.message = value;
        return false;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#assignSocket
     * @private
     * @description
     * assign socket
     */
    assignSocket(socket) {
        console.log("assignSocket");
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#detachSocket
     * @private
     * @description
     * detach socket
     */
    detachSocket(socket) {
        console.log("assignSocket");
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#setTimeout
     * @private
     * @description
     * set timeout
     */
    setTimeout(msecs, callback) {
        return null;
    }
    /**
     * @since 1.0.0
     * @function
     * @name FakeServerResponse#flushHeaders
     * @private
     * @description
     * flush headers
     */
    flushHeaders() {
        console.log("flushHeaders");
    }
}
/**
 * @since 2.0.0
 * @private
 * @class
 * @name FakeWebSocket
 * @constructor
 *
 * @description
 * Implements a dummy socket API providing logic for usage by in tests
 */
class FakeWebSocket {
    /**
     * @since 2.0.0
     * @private
     * @constructor
     * @param {IWebSocketResult} socket The socket result to wrap
     */
    constructor(socket) {
        this.socket = socket;
        this.eventEmitter = new events_1.EventEmitter();
        this.readyState = 0;
        this.onMessage((data) => this.lastReceivedMessage = data);
    }
    /**
     * @inheritDoc
     */
    open() {
        return this.socket
            .open({
            on: this.eventEmitter.on.bind(this.eventEmitter),
            send: (data) => {
                this.eventEmitter.emit("_receive", data);
            },
            close: this.close.bind(this)
        })
            .then(() => {
            this.readyState = 1;
            this.eventEmitter.on("close", () => this.readyState = 3);
        }, (error) => {
            this.readyState = 3;
            throw error;
        });
    }
    /**
     * @inheritDoc
     */
    close() {
        this.readyState = 2;
        this.eventEmitter.emit("close");
        this.socket.finished();
        this.eventEmitter.removeAllListeners();
    }
    /**
     * @inheritDoc
     */
    send(data) {
        if (this.readyState !== 1) {
            throw new Error("Socket must be opened first");
        }
        this.eventEmitter.emit("message", data);
    }
    /**
     * @inheritDoc
     */
    getLastReceivedMessage() {
        return this.lastReceivedMessage;
    }
    /**
     * @inheritDoc
     */
    onMessage(cb) {
        this.eventEmitter.on("_receive", data => cb(data));
    }
}
//# sourceMappingURL=mocks.js.map