"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const logger_1 = require("../logger/logger");
const core_1 = require("../core");
const bootstrap_1 = require("./bootstrap");
const metadata_1 = require("../injector/metadata");
const WebSocket = require("ws");
const socket_1 = require("./socket");
const error_1 = require("../error");
const TYPEX_SOCKET_ID_HEADER = "__typeix_id";
/**
 * @since 1.0.0
 * @function
 * @name httpServer
 * @param {Function} Class Root application module to bootstrap
 * @param {HttpOptions} options Additional HTTP Server options
 * @returns {Injector}
 *
 * @description
 * Run the HTTP server for a given root module.
 */
function httpServer(Class, options) {
    let metadata = metadata_1.Metadata.getComponentConfig(Class);
    // override bootstrap module
    metadata.name = bootstrap_1.BOOTSTRAP_MODULE;
    // set module config
    metadata_1.Metadata.setComponentConfig(Class, metadata);
    let modules = bootstrap_1.createModule(Class);
    let injector = bootstrap_1.getModule(modules).injector;
    let logger = injector.get(logger_1.Logger);
    let server = http_1.createServer();
    server.on("request", (request, response) => bootstrap_1.fireRequest(modules, request, response));
    if (core_1.isString(options.hostname)) {
        server.listen(options.port, options.hostname);
    }
    else {
        server.listen(options.port);
    }
    logger.info("Module.info: Server started", options);
    server.on("error", (e) => logger.error(e.stack));
    if (options.enableWebSockets) {
        configureAndStartWebSockets(modules, logger, server);
    }
    return modules;
}
exports.httpServer = httpServer;
/**
 * @since 2.0.0
 * @function
 * @param {Array<IModule>} modules The list of bootstrapped modules
 * @param {Logger} logger The logger instance
 * @param {"http".Server} server Configured HTTP server
 *
 * @description
 * Configures and starts the WebSockets extensions
 */
function configureAndStartWebSockets(modules, logger, server) {
    const socketResultMap = new Map();
    const wss = new WebSocket.Server({
        server,
        verifyClient: (info, cb) => {
            socket_1.fireWebSocket(modules, info.req)
                .then(result => {
                if (result.error || !core_1.isFunction(result.open)) {
                    if (result.error instanceof error_1.HttpError) {
                        cb(false, result.error.getCode(), result.error.getMessage());
                    }
                    else {
                        cb(false);
                    }
                }
                info.req.headers[TYPEX_SOCKET_ID_HEADER] = result.uuid;
                socketResultMap.set(result.uuid, result);
                cb(true);
            })
                .catch(error => {
                logger.error("WSS.verifyClient: Verification failed", { error, info });
                cb(false);
            });
        }
    });
    wss.on("connection", (ws, request) => {
        logger.info("WSS.info: Socket connected", { url: request.url });
        const idFromHeader = request.headers[TYPEX_SOCKET_ID_HEADER];
        if (!core_1.isPresent(idFromHeader) || core_1.isArray(idFromHeader) || !socketResultMap.has(idFromHeader)) {
            ws.close();
        }
        else {
            const socketResult = socketResultMap.get(idFromHeader);
            const cleanup = () => {
                socketResult.finished();
                socketResultMap.delete(idFromHeader);
            };
            ws.on("close", cleanup);
            ws.on("error", cleanup);
            return socketResult.open(ws);
        }
    });
    wss.on("error", (e) => logger.error(e.stack));
}
//# sourceMappingURL=http.js.map