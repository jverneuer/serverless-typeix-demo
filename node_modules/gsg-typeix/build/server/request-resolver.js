"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var HttpRequestResolver_1, SocketRequestResolver_1;
const injectable_1 = require("../decorators/injectable");
const inject_1 = require("../decorators/inject");
const http_1 = require("http");
const logger_1 = require("../logger/logger");
const router_1 = require("../router/router");
const core_1 = require("../core");
const error_1 = require("../error");
const metadata_1 = require("../injector/metadata");
const bootstrap_1 = require("./bootstrap");
const controller_resolver_1 = require("./controller-resolver");
const events_1 = require("events");
const injector_1 = require("../injector/injector");
const status_code_1 = require("./status-code");
const inspect_1 = require("../logger/inspect");
const socket_resolver_1 = require("./socket-resolver");
exports.MODULE_KEY = "__module__";
exports.ERROR_KEY = "__error__";
/**
 * @since 2.0.0
 * @private
 * @abstract
 * @class
 * @name BaseRequestResolver
 *
 * @description
 * Base class for all kinds of request resolvers providing the general functionality
 */
class BaseRequestResolver {
    /**
     * @since 1.0.0
     * @function
     * @name BaseRequestResolver#process
     * @private
     * @description
     * Resolves route and resolves module before processing the module
     */
    process() {
        // process request
        return this.router
            .parseRequest(this.url.pathname, this.request.method, this.request.headers)
            .then((resolvedRoute) => {
            this.logger.debug("Route.parseRequest", {
                method: this.request.method,
                path: this.url.pathname,
                route: resolvedRoute
            });
            /**
             * Copy query params to params if thy are not defined in path
             */
            if (core_1.isPresent(this.url.query)) {
                Object.keys(this.url.query).forEach(key => {
                    if (!resolvedRoute.params.hasOwnProperty(key)) {
                        resolvedRoute.params[key] = this.url.query[key];
                    }
                });
            }
            /**
             * ON POST, PATCH, PUT process body
             */
            if ([router_1.Methods.POST, router_1.Methods.PATCH, router_1.Methods.PUT].indexOf(resolvedRoute.method) > -1) {
                this.request.on("data", item => this.data.push(item));
                return new Promise((resolve, reject) => {
                    this.request.on("error", reject.bind(this));
                    this.request.on("end", resolve.bind(this, resolvedRoute));
                });
            }
            return resolvedRoute;
        })
            .then((resolvedRoute) => {
            let resolvedModule = this.getResolvedModule(resolvedRoute);
            this.injector.set(exports.MODULE_KEY, resolvedModule);
            return resolvedModule;
        })
            .then(resolvedModule => this.processModule(resolvedModule))
            .catch(data => this.handleError(data));
    }
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#getResolvedModule
     * @param {IResolvedRoute} resolvedRoute The resolved route
     * @return {IResolvedModule} The module belonging to the resolved route
     *
     * @description
     * Resolve route and return the corresponding resolved module as well as controller and action (if available)
     */
    getResolvedModule(resolvedRoute) {
        let [module, controller, action] = resolvedRoute.route.split("/");
        let resolvedModule = !core_1.isPresent(action) ? bootstrap_1.getModule(this.modules) : bootstrap_1.getModule(this.modules, module);
        if (core_1.isFalsy(resolvedModule)) {
            throw new error_1.HttpError(500, "Module with route " + resolvedRoute.route + " is not registered in system," +
                " please check your route configuration!", resolvedRoute);
        }
        return {
            action: !core_1.isPresent(action) ? controller : action,
            endpoint: !core_1.isPresent(action) ? module : controller,
            data: this.data,
            module: resolvedModule,
            resolvedRoute
        };
    }
}
__decorate([
    inject_1.Inject("request"),
    __metadata("design:type", http_1.IncomingMessage)
], BaseRequestResolver.prototype, "request", void 0);
__decorate([
    inject_1.Inject(injector_1.Injector),
    __metadata("design:type", injector_1.Injector)
], BaseRequestResolver.prototype, "injector", void 0);
__decorate([
    inject_1.Inject(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], BaseRequestResolver.prototype, "logger", void 0);
__decorate([
    inject_1.Inject(router_1.Router),
    __metadata("design:type", router_1.Router)
], BaseRequestResolver.prototype, "router", void 0);
__decorate([
    inject_1.Inject("data"),
    __metadata("design:type", Array)
], BaseRequestResolver.prototype, "data", void 0);
__decorate([
    inject_1.Inject("UUID"),
    __metadata("design:type", String)
], BaseRequestResolver.prototype, "id", void 0);
__decorate([
    inject_1.Inject("url"),
    __metadata("design:type", Object)
], BaseRequestResolver.prototype, "url", void 0);
__decorate([
    inject_1.Inject("modules"),
    __metadata("design:type", Array)
], BaseRequestResolver.prototype, "modules", void 0);
exports.BaseRequestResolver = BaseRequestResolver;
/**
 * @since 1.0.0
 * @enum
 * @name Renderer
 * @description
 * RenderType types
 *
 * @private
 */
var RenderType;
(function (RenderType) {
    RenderType[RenderType["REDIRECT"] = 0] = "REDIRECT";
    RenderType[RenderType["DATA_HANDLER"] = 1] = "DATA_HANDLER";
    RenderType[RenderType["CUSTOM_ERROR_HANDLER"] = 2] = "CUSTOM_ERROR_HANDLER";
    RenderType[RenderType["DEFAULT_ERROR_HANDLER"] = 3] = "DEFAULT_ERROR_HANDLER";
})(RenderType = exports.RenderType || (exports.RenderType = {}));
/**
 * @since 2.0.0
 * @private
 * @class
 * @constructor
 * @name HttpRequestResolver
 *
 * @description
 * Does request resolution for regular HTTP requests
 */
let HttpRequestResolver = HttpRequestResolver_1 = class HttpRequestResolver extends BaseRequestResolver {
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#getControllerProvider
     * @param {IResolvedModule} resolvedModule The resolved module
     *
     * @description
     * Returns a controller provider
     */
    static getControllerProvider(resolvedModule) {
        let provider = metadata_1.Metadata.verifyProvider(resolvedModule.module.provider);
        let moduleMetadata = metadata_1.Metadata.getComponentConfig(provider.provide);
        let controllerProvider = moduleMetadata.controllers
            .map(item => metadata_1.Metadata.verifyProvider(item))
            .find((Class) => {
            let metadata = metadata_1.Metadata.getComponentConfig(Class.provide);
            return metadata.name === resolvedModule.endpoint;
        });
        if (!core_1.isPresent(controllerProvider)) {
            throw new error_1.HttpError(status_code_1.Status.Bad_Request, `You must define controller within current route: ${resolvedModule.resolvedRoute.route}`, {
                actionName: resolvedModule.action,
                controllerName: resolvedModule.endpoint,
                resolvedRoute: resolvedModule.resolvedRoute
            });
        }
        return controllerProvider;
    }
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#afterConstruct
     *
     * @description
     * Create event listeners for status code and content type change
     */
    afterConstruct() {
        this.eventEmitter.on("statusCode", value => this.statusCode = value);
        this.eventEmitter.on("contentType", value => this.contentType = value);
        this.eventEmitter.on("redirectTo", value => this.redirectTo = value);
    }
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#processError
     * @param {Object} data
     * @param {boolean} isCustom
     * @return {Promise<Buffer|string>} Promise to be resolved when error handling was successful
     *
     * @description
     * Process error handling
     * @todo fix custom error handling
     */
    processError(data, isCustom) {
        return __awaiter(this, void 0, void 0, function* () {
            // force HttpError to be thrown
            if (!(data instanceof error_1.HttpError)) {
                let _error = data;
                data = new error_1.HttpError(status_code_1.Status.Internal_Server_Error, _error.message, {});
                data.stack = _error.stack;
            }
            // log error message
            this.logger.error(data.message, {
                id: this.id,
                method: this.request.method,
                request: this.url,
                url: this.request.url,
                data
            });
            // status code is mutable
            this.statusCode = data.getCode();
            if (core_1.isTruthy(isCustom) && this.router.hasError()) {
                let route;
                if (this.injector.has(exports.MODULE_KEY)) {
                    let iResolvedModule = this.injector.get(exports.MODULE_KEY);
                    route = this.router.getError(iResolvedModule.module.name);
                }
                else {
                    route = this.router.getError();
                }
                let iResolvedErrorModule = this.getResolvedModule({
                    method: router_1.Methods.GET,
                    params: {},
                    route
                });
                if (core_1.isTruthy(iResolvedErrorModule)) {
                    return yield this.processModule(iResolvedErrorModule, data);
                }
            }
            return yield inspect_1.clean(data.toString());
        });
    }
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#render
     * @param {Buffer|String} response The produced response so far
     * @param {RenderType} type How to render the response
     *
     * @description
     * Renders the given response and transfers the final data to the client
     */
    render(response, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let headers = { "Content-Type": this.contentType };
            switch (type) {
                case RenderType.DATA_HANDLER:
                    if (core_1.isString(response) || (response instanceof Buffer)) {
                        this.response.writeHead(this.statusCode, headers);
                        this.response.write(response);
                        this.response.end();
                    }
                    else {
                        this.logger.error("Invalid response type", {
                            id: this.id,
                            response: response,
                            type: typeof response
                        });
                        throw new error_1.HttpError(status_code_1.Status.Bad_Request, "ResponseType must be string or buffer", {
                            response
                        });
                    }
                    break;
                case RenderType.CUSTOM_ERROR_HANDLER:
                    response = yield this.processError(response, true);
                    this.response.writeHead(this.statusCode, headers);
                    this.response.write(response);
                    this.response.end();
                    break;
                case RenderType.DEFAULT_ERROR_HANDLER:
                    response = yield this.processError(response, false);
                    this.response.writeHead(this.statusCode, headers);
                    this.response.write(response);
                    this.response.end();
                    break;
                case RenderType.REDIRECT:
                    this.response.setHeader("Location", this.redirectTo.url);
                    this.response.writeHead(this.redirectTo.code);
                    this.response.end();
                    break;
                default:
                    this.response.writeHead(500);
                    this.response.write(`Invalid RenderType provided ${core_1.isPresent(response) ? response.toString() : ""}`);
                    this.response.end();
                    break;
            }
            return response;
        });
    }
    /**
     * @inheritDoc
     */
    processModule(resolvedModule, error) {
        let providers = [
            { provide: "data", useValue: this.data },
            { provide: "request", useValue: this.request },
            { provide: "response", useValue: this.response },
            { provide: "url", useValue: this.url },
            { provide: "UUID", useValue: this.id },
            { provide: "controllerProvider", useValue: HttpRequestResolver_1.getControllerProvider(resolvedModule) },
            { provide: "actionName", useValue: resolvedModule.action },
            { provide: "resolvedRoute", useValue: resolvedModule.resolvedRoute },
            { provide: "isChainStopped", useValue: false },
            { provide: exports.ERROR_KEY, useValue: core_1.isTruthy(error) ? error : new error_1.HttpError(500) },
            { provide: events_1.EventEmitter, useValue: this.eventEmitter }
        ];
        /**
         * Create and resolve
         */
        let childInjector = injector_1.Injector.createAndResolveChild(resolvedModule.module.injector, controller_resolver_1.ControllerResolver, providers);
        /**
         * On finish destroy injector
         */
        this.response.on("finish", () => childInjector.destroy());
        /**
         * Get request instance
         * @type {any}
         */
        let pRequest = childInjector.get(controller_resolver_1.ControllerResolver);
        /**
         * Process request and render
         */
        return pRequest
            .process()
            .then(data => this.render(data, core_1.isFalsy(this.redirectTo) ? RenderType.DATA_HANDLER : RenderType.REDIRECT));
    }
    /**
     * @since 1.0.0
     * @private
     * @function
     * @name HttpRequestResolver#handleError
     * @param {any} data Any error or data a promise during processing had been rejected
     *
     * @description
     * Tries to render the data using a custom registered error handler or falls back to default error rendering.
     */
    handleError(data) {
        this
            .render(data, RenderType.CUSTOM_ERROR_HANDLER)
            .catch(() => this.render(data, RenderType.DEFAULT_ERROR_HANDLER));
    }
};
__decorate([
    inject_1.Inject("response"),
    __metadata("design:type", http_1.ServerResponse)
], HttpRequestResolver.prototype, "response", void 0);
__decorate([
    inject_1.Inject("statusCode", true),
    __metadata("design:type", Number)
], HttpRequestResolver.prototype, "statusCode", void 0);
__decorate([
    inject_1.Inject("contentType", true),
    __metadata("design:type", String)
], HttpRequestResolver.prototype, "contentType", void 0);
__decorate([
    inject_1.Inject(events_1.EventEmitter),
    __metadata("design:type", events_1.EventEmitter)
], HttpRequestResolver.prototype, "eventEmitter", void 0);
HttpRequestResolver = HttpRequestResolver_1 = __decorate([
    injectable_1.Injectable()
], HttpRequestResolver);
exports.HttpRequestResolver = HttpRequestResolver;
/**
 * @since 2.0.0
 * @private
 * @class
 * @name SocketRequestResolver
 * @constructor
 *
 * @description
 * Handles the current request and resolves to a socket
 */
let SocketRequestResolver = SocketRequestResolver_1 = class SocketRequestResolver extends BaseRequestResolver {
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketRequestResolver#getSocketProvider
     * @param {IResolvedModule} resolvedModule The resolved module to make into a socket
     * @return {IProvider} The designated {@link WebSocket} provider
     *
     * @description
     * This method tries to find the designated {@link WebSocket} for the given resolved module.
     */
    static getSocketProvider(resolvedModule) {
        let provider = metadata_1.Metadata.verifyProvider(resolvedModule.module.provider);
        let moduleMetadata = metadata_1.Metadata.getComponentConfig(provider.provide);
        let socketProvider = moduleMetadata.sockets
            .map(item => metadata_1.Metadata.verifyProvider(item))
            .find((Class) => {
            let metadata = metadata_1.Metadata.getComponentConfig(Class.provide);
            return metadata.name === resolvedModule.endpoint;
        });
        if (!core_1.isPresent(socketProvider)) {
            throw new error_1.HttpError(status_code_1.Status.Bad_Request, `You must define socket within current route: ${resolvedModule.resolvedRoute.route}`, {
                socketName: resolvedModule.endpoint,
                resolvedRoute: resolvedModule.resolvedRoute
            });
        }
        return socketProvider;
    }
    /**
     * @inheritDoc
     */
    processModule(resolvedModule) {
        const providers = [
            { provide: "data", useValue: this.data },
            { provide: "request", useValue: this.request },
            { provide: "UUID", useValue: this.id },
            { provide: "resolvedRoute", useValue: resolvedModule.resolvedRoute },
            { provide: "socketProvider", useValue: SocketRequestResolver_1.getSocketProvider(resolvedModule) },
            events_1.EventEmitter
        ];
        const childInjector = injector_1.Injector.createAndResolveChild(resolvedModule.module.injector, socket_resolver_1.SocketResolver, providers);
        const socketResolver = childInjector.get(socket_resolver_1.SocketResolver);
        this.logger.debug("SocketRequestResolver.processModule: resolved SocketResolver");
        socketResolver.getEventEmitter().on("destroy", () => {
            childInjector.destroy();
        });
        return socketResolver.process();
    }
    /**
     * @since 2.0.0
     * @private
     * @function
     * @name SocketRequestResolver#handleError
     * @param {any} data Any error or data a promise during processing had been rejected
     *
     * @description
     * Logs the error and throws an {@link HttpError} to indicate that it's not possible
     * to resolve to a socket.
     */
    handleError(data) {
        this.logger.error("SocketRequestResolver.handleError: an error occurred", { data });
        if (data instanceof error_1.HttpError) {
            throw data;
        }
        throw new error_1.HttpError(status_code_1.Status.Internal_Server_Error, "Could not resolve socket");
    }
};
SocketRequestResolver = SocketRequestResolver_1 = __decorate([
    injectable_1.Injectable()
], SocketRequestResolver);
exports.SocketRequestResolver = SocketRequestResolver;
//# sourceMappingURL=request-resolver.js.map