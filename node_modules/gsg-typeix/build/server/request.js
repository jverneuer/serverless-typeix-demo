"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../core");
const decorators_1 = require("../decorators");
const parsers_1 = require("../parsers");
const http_1 = require("http");
const controller_resolver_1 = require("./controller-resolver");
/**
 * Cookie parse regex
 * @type {RegExp}
 */
const COOKIE_PARSE_REGEX = /(\w+[^=]+)=([^;]+)/g;
class AbstractRequest {
    /**
     * @since 1.0.0
     * @function
     * @name Request#getConnection
     *
     * @description
     * Get connection data
     */
    getConnection() {
        const request = this.getIncomingMessage();
        return {
            uuid: this.getId(),
            method: request.method,
            url: request.url,
            httpVersion: request.httpVersion,
            httpVersionMajor: request.httpVersionMajor,
            httpVersionMinor: request.httpVersionMinor,
            remoteAddress: request.connection.remoteAddress,
            remoteFamily: request.connection.remoteFamily,
            remotePort: request.connection.remotePort,
            localAddress: request.connection.localAddress,
            localPort: request.connection.localPort
        };
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getCookies
     *
     * @description
     * Return parsed cookies
     */
    getCookies() {
        if (core_1.isPresent(this.cookies)) {
            return this.cookies;
        }
        // get cookie string
        let cookie = this.getRequestHeader("Cookie");
        if (core_1.isPresent(cookie)) {
            this.cookies = {};
            // parse cookies
            cookie.match(COOKIE_PARSE_REGEX)
                .map(item => item.split(COOKIE_PARSE_REGEX).slice(1, -1))
                .map(item => {
                return {
                    key: item.shift(),
                    value: item.shift()
                };
            })
                .forEach(item => {
                this.cookies[item.key] = item.value;
            });
            return this.cookies;
        }
        return {};
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getCookie
     *
     * @description
     * Return request headers
     */
    getCookie(name) {
        let cookies = this.getCookies();
        return cookies[name];
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getRequestHeaders
     *
     * @description
     * Return request headers
     */
    getRequestHeaders() {
        return this.getIncomingMessage().headers;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getRequestHeader
     *
     * @description
     * Return request header by name
     */
    getRequestHeader(name) {
        let requestHeaders = this.getRequestHeaders();
        let headers = core_1.isPresent(requestHeaders) ? requestHeaders : {};
        return headers[name.toLocaleLowerCase()];
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getParams
     *
     * @description
     * Get all request parameters
     */
    getParams() {
        return core_1.isPresent(this.getResolvedRoute().params) ? this.getResolvedRoute().params : {};
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getParam
     * @param {string} name
     *
     * @description
     * Get resolve route param
     */
    getParam(name) {
        let params = this.getParams();
        return params[name];
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getMethod
     *
     * @description
     * Return resolved route method
     */
    getMethod() {
        return this.getResolvedRoute().method;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getRoute
     *
     * @description
     * Return resolved route name
     */
    getRoute() {
        return this.getResolvedRoute().route;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getBody
     * @private
     *
     * @description
     * Get request body if present only on POST, PUT, PATCH
     */
    getBody() {
        return Buffer.concat(this.getRawData());
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#getBodyAsMultiPart
     * @param {string} encoding
     *
     * @description
     * Get request body as multipart if present only on POST, PUT, PATCH
     */
    getBodyAsMultiPart(encoding = "utf8") {
        let buffer = this.getBody();
        let contentType = this.getRequestHeader("content-type");
        let parser = new parsers_1.MultiPart(contentType, encoding);
        return parser.parse(buffer);
    }
}
exports.AbstractRequest = AbstractRequest;
/**
 * @since 2.0.0
 * @class
 * @name BaseRequest
 * @constructor
 * @description
 * Provides a basic API to the original request - does only support retrieving information.
 */
let BaseRequest = class BaseRequest extends AbstractRequest {
    getId() {
        return this.id;
    }
    getIncomingMessage() {
        return this.incomingMessage;
    }
    getResolvedRoute() {
        return this.resolvedRoute;
    }
    getRawData() {
        return this.data;
    }
};
__decorate([
    decorators_1.Inject("request"),
    __metadata("design:type", http_1.IncomingMessage)
], BaseRequest.prototype, "incomingMessage", void 0);
__decorate([
    decorators_1.Inject("UUID"),
    __metadata("design:type", String)
], BaseRequest.prototype, "id", void 0);
__decorate([
    decorators_1.Inject("data"),
    __metadata("design:type", Array)
], BaseRequest.prototype, "data", void 0);
__decorate([
    decorators_1.Inject("resolvedRoute"),
    __metadata("design:type", Object)
], BaseRequest.prototype, "resolvedRoute", void 0);
BaseRequest = __decorate([
    decorators_1.Injectable()
], BaseRequest);
exports.BaseRequest = BaseRequest;
/**
 * @since 1.0.0
 * @class
 * @name Request
 * @constructor
 * @description
 * Get request reflection to limit public api
 */
let Request = class Request extends AbstractRequest {
    /**
     * @since 1.0.0
     * @function
     * @name Request#onDestroy
     *
     * @description
     * Add destroy event to public api
     */
    onDestroy(callback) {
        this.controllerResolver.getEventEmitter().once("destroy", callback);
    }
    /**
     * @since 0.0.1
     * @function
     * @name Request#setResponseCookie
     * @param {String} key cookie name
     * @param {String} value cookie value
     * @param {String|Object|Number} expires expire date
     * @param {String} path cookie path
     * @param {String} domain cookie domain
     * @param {Boolean} isHttpOnly is http only
     * @description
     * Sets an cookie header
     */
    setCookie(key, value, expires, path, domain, isHttpOnly) {
        let cookie = key + "=" + value;
        if (core_1.isPresent(expires) && core_1.isNumber(expires)) {
            let date = new Date();
            date.setTime(date.getTime() + expires);
            cookie += "; Expires=";
            cookie += date.toUTCString();
        }
        else if (core_1.isPresent(expires) && core_1.isString(expires)) {
            cookie += "; Expires=" + expires;
        }
        else if (core_1.isPresent(expires) && core_1.isDate(expires)) {
            cookie += "; Expires=";
            cookie += expires.toUTCString();
        }
        if (core_1.isPresent(path)) {
            cookie += "; Path=" + path;
        }
        if (core_1.isPresent(domain)) {
            cookie += "; Domain=" + domain;
        }
        if (core_1.isTruthy(isHttpOnly)) {
            cookie += "; HttpOnly";
        }
        this.setResponseHeader("Set-cookie", cookie);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#setResponseHeader
     * @param {String} name
     * @param {String} value
     *
     * @description
     * Set response header
     */
    setResponseHeader(name, value) {
        this.controllerResolver.getServerResponse().setHeader(name, value);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#setContentType
     * @param {String} value
     *
     * @description
     * Set response content type
     */
    setContentType(value) {
        this.controllerResolver.getEventEmitter().emit("contentType", value);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#setStatusCode
     *
     * @description
     * Set status code
     */
    setStatusCode(code) {
        this.controllerResolver.getEventEmitter().emit("statusCode", code);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#stopChain
     *
     * @description
     * Stops action chain
     */
    stopChain() {
        this.controllerResolver.stopChain();
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#redirectTo
     *
     * @description
     * Stops action chain
     */
    redirectTo(url, code) {
        this.stopChain();
        this.controllerResolver.getEventEmitter().emit("redirectTo", {
            code, url
        });
    }
    getId() {
        return this.controllerResolver.getId();
    }
    getIncomingMessage() {
        return this.controllerResolver.getIncomingMessage();
    }
    getResolvedRoute() {
        return this.controllerResolver.getResolvedRoute();
    }
    getRawData() {
        return this.controllerResolver.getBody();
    }
};
__decorate([
    decorators_1.Inject("controllerResolver"),
    __metadata("design:type", controller_resolver_1.ControllerResolver)
], Request.prototype, "controllerResolver", void 0);
Request = __decorate([
    decorators_1.Injectable()
], Request);
exports.Request = Request;
//# sourceMappingURL=request.js.map