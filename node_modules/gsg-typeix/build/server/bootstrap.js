"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const injector_1 = require("../injector/injector");
const logger_1 = require("../logger/logger");
const core_1 = require("../core");
const metadata_1 = require("../injector/metadata");
const request_resolver_1 = require("./request-resolver");
const url_1 = require("url");
const events_1 = require("events");
const status_code_1 = require("./status-code");
const router_1 = require("../router/router");
exports.BOOTSTRAP_PROVIDERS = [logger_1.Logger, router_1.Router];
exports.BOOTSTRAP_MODULE = "root";
/**
 * @since 1.0.0
 * @function
 * @name doModulesDuplicationCheck
 * @param {Array<IModule>} modules
 * @param {IModuleMetadata} metadata
 * @param {IProvider} provider
 */
function doModulesDuplicationCheck(modules, metadata, provider) {
    let duplicationCheck = modules.slice();
    /**
     * Duplication check
     */
    while (duplicationCheck.length) {
        let importedModule = duplicationCheck.pop();
        /**
         * Provider duplication check
         */
        if (!core_1.isEqual(provider, importedModule) && core_1.isEqual(metadata.name, importedModule.name)) {
            let message = "Multiple modules with same name detected! Module name: ";
            message += importedModule.name + " is defined in modules: [" + metadata_1.Metadata.getName(provider) + ", ";
            message += metadata_1.Metadata.getName(importedModule) + "]";
            message += " Please provide unique names to modules!";
            throw new Error(message);
        }
    }
}
exports.doModulesDuplicationCheck = doModulesDuplicationCheck;
/**
 * @since 1.0.0
 * @function
 * @name getModule
 * @param {Array<IModule>} modules
 * @param {String} name
 *
 * @description
 * Find root module
 */
function getModule(modules, name = exports.BOOTSTRAP_MODULE) {
    return modules.find(item => item.name === name);
}
exports.getModule = getModule;
/**
 * @since 1.0.0
 * @function
 * @name createModule
 * @param {Provider|Function} Class
 * @param {Injector} sibling
 * @param {Array<IModule>} modules list
 *
 * @description
 * Bootstrap modules recursive handler imported modules and export services which is needed
 *
 */
function createModule(Class, sibling, modules = []) {
    let provider = metadata_1.Metadata.verifyProvider(Class);
    let metadata = metadata_1.Metadata.getComponentConfig(provider.provide);
    // Check if module is present then return module reference list
    if (core_1.isTruthy(getModule(modules, metadata.name))) {
        return modules;
    }
    // Create new injector instance
    let injector = new injector_1.Injector();
    let providers = [];
    // Set name for provider
    injector.setName(provider);
    // Create instance of Router && Logger if thy are provided
    exports.BOOTSTRAP_PROVIDERS.forEach(iClass => {
        if (metadata_1.Metadata.inProviders(metadata.providers, iClass)) {
            injector.createAndResolve(metadata_1.Metadata.getProviderInProviders(metadata.providers, iClass), []);
        }
        else if (core_1.isTruthy(sibling) && sibling.has(iClass)) {
            injector.set(iClass, sibling.get(iClass));
        }
    });
    /**
     * Imports must be initialized before first
     */
    if (core_1.isArray(metadata.imports)) {
        metadata.imports.forEach(importModule => {
            let importProvider = metadata_1.Metadata.verifyProvider(importModule);
            let importMetadata = metadata_1.Metadata.getComponentConfig(importProvider.provide);
            /**
             * Create module only if is not already created
             */
            if (core_1.isFalsy(getModule(modules, importMetadata.name))) {
                /**
                 * Create module first
                 * @type {Array<IModule>}
                 */
                let importModules = createModule(importModule, injector, modules);
                let module = getModule(importModules, importMetadata.name);
                /**
                 * Export providers to importers
                 */
                if (core_1.isArray(importMetadata.exports)) {
                    providers = providers.concat(importMetadata.exports.map((iClass) => {
                        return {
                            provide: iClass,
                            useValue: module.injector.get(iClass)
                        };
                    }));
                }
                modules = importModules.filter((bI) => core_1.isFalsy(modules.find((aI) => aI.name === bI.name))).concat(modules);
            }
            else {
                let module = getModule(modules, importMetadata.name);
                /**
                 * Export providers to importers
                 */
                if (core_1.isArray(importMetadata.exports)) {
                    providers = providers.concat(importMetadata.exports.map((iClass) => {
                        return {
                            provide: iClass,
                            useValue: module.injector.get(iClass)
                        };
                    }));
                }
            }
        });
    }
    /**
     * Create module after imports are initialized
     */
    injector.createAndResolve(provider, providers);
    /**
     * Check duplicates
     */
    doModulesDuplicationCheck(modules, metadata, provider);
    /**
     * Add module to list
     */
    modules.push({
        injector,
        provider,
        name: metadata.name
    });
    return modules;
}
exports.createModule = createModule;
/**
 * @since 1.0.0
 * @function
 * @name fireRequest
 * @param {Array<IModule>} modules list of all modules bootstrapped
 * @param {IncomingMessage} request event emitter
 * @param {ServerResponse} response event emitter
 * @return {string|Buffer} data from controller
 *
 * @description
 * Use fireRequest to process request itself, this function is used by http/https server or
 * You can fire fake request
 */
function fireRequest(modules, request, response) {
    let rootInjector = getModule(modules).injector;
    let logger = rootInjector.get(logger_1.Logger);
    /**
     * Create HttpRequestResolver injector
     */
    let routeResolverInjector = injector_1.Injector.createAndResolveChild(rootInjector, request_resolver_1.HttpRequestResolver, [
        { provide: "url", useValue: url_1.parse(request.url, true) },
        { provide: "UUID", useValue: core_1.uuid() },
        { provide: "data", useValue: [] },
        { provide: "contentType", useValue: "text/html" },
        { provide: "statusCode", useValue: status_code_1.Status.OK },
        { provide: "request", useValue: request },
        { provide: "response", useValue: response },
        { provide: "modules", useValue: modules },
        events_1.EventEmitter
    ]);
    /**
     * Get HttpRequestResolver instance
     */
    let rRouteResolver = routeResolverInjector.get(request_resolver_1.HttpRequestResolver);
    /**
     * On finish destroy injector
     */
    response.on("finish", () => routeResolverInjector.destroy());
    return rRouteResolver
        .process()
        .catch(error => logger.error("ControllerResolver.error", {
        stack: error.stack,
        url: request.url,
        error
    }));
}
exports.fireRequest = fireRequest;
//# sourceMappingURL=bootstrap.js.map